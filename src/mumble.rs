// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,Default)]
pub struct Version {
    // message fields
    version: ::std::option::Option<u32>,
    release: ::protobuf::SingularField<::std::string::String>,
    os: ::protobuf::SingularField<::std::string::String>,
    os_version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Version {}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Version {
        static mut instance: ::protobuf::lazy::Lazy<Version> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Version,
        };
        unsafe {
            instance.get(|| {
                Version {
                    version: ::std::option::Option::None,
                    release: ::protobuf::SingularField::none(),
                    os: ::protobuf::SingularField::none(),
                    os_version: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version<'a>(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    // optional string release = 2;

    pub fn clear_release(&mut self) {
        self.release.clear();
    }

    pub fn has_release(&self) -> bool {
        self.release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release(&mut self, v: ::std::string::String) {
        self.release = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.release.is_none() {
            self.release.set_default();
        };
        self.release.as_mut().unwrap()
    }

    // Take field
    pub fn take_release(&mut self) -> ::std::string::String {
        self.release.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_release<'a>(&'a self) -> &'a str {
        match self.release.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string os = 3;

    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        };
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_os<'a>(&'a self) -> &'a str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string os_version = 4;

    pub fn clear_os_version(&mut self) {
        self.os_version.clear();
    }

    pub fn has_os_version(&self) -> bool {
        self.os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os_version(&mut self, v: ::std::string::String) {
        self.os_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.os_version.is_none() {
            self.os_version.set_default();
        };
        self.os_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_os_version(&mut self) -> ::std::string::String {
        self.os_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_os_version<'a>(&'a self) -> &'a str {
        match self.os_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Version {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.release));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os_version));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.release.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.os.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.os_version.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.release.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.os.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.os_version.as_ref() {
            try!(os.write_string(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Version>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Version {
    fn new() -> Version {
        Version::new()
    }

    fn descriptor_static(_: ::std::option::Option<Version>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "version",
                    Version::has_version,
                    Version::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "release",
                    Version::has_release,
                    Version::get_release,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "os",
                    Version::has_os,
                    Version::get_os,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "os_version",
                    Version::has_os_version,
                    Version::get_os_version,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Version>(
                    "Version",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Version {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_release();
        self.clear_os();
        self.clear_os_version();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Version {
    fn eq(&self, other: &Version) -> bool {
        self.version == other.version &&
        self.release == other.release &&
        self.os == other.os &&
        self.os_version == other.os_version &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UDPTunnel {
    // message fields
    packet: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UDPTunnel {}

impl UDPTunnel {
    pub fn new() -> UDPTunnel {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UDPTunnel {
        static mut instance: ::protobuf::lazy::Lazy<UDPTunnel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UDPTunnel,
        };
        unsafe {
            instance.get(|| {
                UDPTunnel {
                    packet: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bytes packet = 1;

    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: ::std::vec::Vec<u8>) {
        self.packet = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.packet.is_none() {
            self.packet.set_default();
        };
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> ::std::vec::Vec<u8> {
        self.packet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_packet<'a>(&'a self) -> &'a [u8] {
        match self.packet.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for UDPTunnel {
    fn is_initialized(&self) -> bool {
        if self.packet.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.packet));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packet.iter() {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packet.as_ref() {
            try!(os.write_bytes(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UDPTunnel>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UDPTunnel {
    fn new() -> UDPTunnel {
        UDPTunnel::new()
    }

    fn descriptor_static(_: ::std::option::Option<UDPTunnel>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "packet",
                    UDPTunnel::has_packet,
                    UDPTunnel::get_packet,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UDPTunnel>(
                    "UDPTunnel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UDPTunnel {
    fn clear(&mut self) {
        self.clear_packet();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UDPTunnel {
    fn eq(&self, other: &UDPTunnel) -> bool {
        self.packet == other.packet &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UDPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Authenticate {
    // message fields
    username: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    tokens: ::protobuf::RepeatedField<::std::string::String>,
    celt_versions: ::std::vec::Vec<i32>,
    opus: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Authenticate {}

impl Authenticate {
    pub fn new() -> Authenticate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Authenticate {
        static mut instance: ::protobuf::lazy::Lazy<Authenticate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Authenticate,
        };
        unsafe {
            instance.get(|| {
                Authenticate {
                    username: ::protobuf::SingularField::none(),
                    password: ::protobuf::SingularField::none(),
                    tokens: ::protobuf::RepeatedField::new(),
                    celt_versions: ::std::vec::Vec::new(),
                    opus: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string username = 1;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        };
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_username<'a>(&'a self) -> &'a str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        };
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password<'a>(&'a self) -> &'a str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string tokens = 3;

    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }

    pub fn get_tokens<'a>(&'a self) -> &'a [::std::string::String] {
        &self.tokens
    }

    // repeated int32 celt_versions = 4;

    pub fn clear_celt_versions(&mut self) {
        self.celt_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_celt_versions(&mut self, v: ::std::vec::Vec<i32>) {
        self.celt_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_celt_versions<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.celt_versions
    }

    // Take field
    pub fn take_celt_versions(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.celt_versions, ::std::vec::Vec::new())
    }

    pub fn get_celt_versions<'a>(&'a self) -> &'a [i32] {
        &self.celt_versions
    }

    // optional bool opus = 5;

    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }

    pub fn get_opus<'a>(&self) -> bool {
        self.opus.unwrap_or(false)
    }
}

impl ::protobuf::Message for Authenticate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tokens));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.celt_versions));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.opus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.username.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.password.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.tokens.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.celt_versions.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.opus.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.username.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.password.as_ref() {
            try!(os.write_string(2, &v));
        };
        for v in self.tokens.iter() {
            try!(os.write_string(3, &v));
        };
        for v in self.celt_versions.iter() {
            try!(os.write_int32(4, *v));
        };
        if let Some(v) = self.opus {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Authenticate>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Authenticate {
    fn new() -> Authenticate {
        Authenticate::new()
    }

    fn descriptor_static(_: ::std::option::Option<Authenticate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "username",
                    Authenticate::has_username,
                    Authenticate::get_username,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "password",
                    Authenticate::has_password,
                    Authenticate::get_password,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "tokens",
                    Authenticate::get_tokens,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_i32_accessor(
                    "celt_versions",
                    Authenticate::get_celt_versions,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "opus",
                    Authenticate::has_opus,
                    Authenticate::get_opus,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Authenticate>(
                    "Authenticate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Authenticate {
    fn clear(&mut self) {
        self.clear_username();
        self.clear_password();
        self.clear_tokens();
        self.clear_celt_versions();
        self.clear_opus();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Authenticate {
    fn eq(&self, other: &Authenticate) -> bool {
        self.username == other.username &&
        self.password == other.password &&
        self.tokens == other.tokens &&
        self.celt_versions == other.celt_versions &&
        self.opus == other.opus &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Authenticate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Ping {
    // message fields
    timestamp: ::std::option::Option<u64>,
    good: ::std::option::Option<u32>,
    late: ::std::option::Option<u32>,
    lost: ::std::option::Option<u32>,
    resync: ::std::option::Option<u32>,
    udp_packets: ::std::option::Option<u32>,
    tcp_packets: ::std::option::Option<u32>,
    udp_ping_avg: ::std::option::Option<f32>,
    udp_ping_var: ::std::option::Option<f32>,
    tcp_ping_avg: ::std::option::Option<f32>,
    tcp_ping_var: ::std::option::Option<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Ping {}

impl Ping {
    pub fn new() -> Ping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Ping {
        static mut instance: ::protobuf::lazy::Lazy<Ping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ping,
        };
        unsafe {
            instance.get(|| {
                Ping {
                    timestamp: ::std::option::Option::None,
                    good: ::std::option::Option::None,
                    late: ::std::option::Option::None,
                    lost: ::std::option::Option::None,
                    resync: ::std::option::Option::None,
                    udp_packets: ::std::option::Option::None,
                    tcp_packets: ::std::option::Option::None,
                    udp_ping_avg: ::std::option::Option::None,
                    udp_ping_var: ::std::option::Option::None,
                    tcp_ping_avg: ::std::option::Option::None,
                    tcp_ping_var: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint64 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    // optional uint32 good = 2;

    pub fn clear_good(&mut self) {
        self.good = ::std::option::Option::None;
    }

    pub fn has_good(&self) -> bool {
        self.good.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good(&mut self, v: u32) {
        self.good = ::std::option::Option::Some(v);
    }

    pub fn get_good<'a>(&self) -> u32 {
        self.good.unwrap_or(0)
    }

    // optional uint32 late = 3;

    pub fn clear_late(&mut self) {
        self.late = ::std::option::Option::None;
    }

    pub fn has_late(&self) -> bool {
        self.late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late(&mut self, v: u32) {
        self.late = ::std::option::Option::Some(v);
    }

    pub fn get_late<'a>(&self) -> u32 {
        self.late.unwrap_or(0)
    }

    // optional uint32 lost = 4;

    pub fn clear_lost(&mut self) {
        self.lost = ::std::option::Option::None;
    }

    pub fn has_lost(&self) -> bool {
        self.lost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lost(&mut self, v: u32) {
        self.lost = ::std::option::Option::Some(v);
    }

    pub fn get_lost<'a>(&self) -> u32 {
        self.lost.unwrap_or(0)
    }

    // optional uint32 resync = 5;

    pub fn clear_resync(&mut self) {
        self.resync = ::std::option::Option::None;
    }

    pub fn has_resync(&self) -> bool {
        self.resync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resync(&mut self, v: u32) {
        self.resync = ::std::option::Option::Some(v);
    }

    pub fn get_resync<'a>(&self) -> u32 {
        self.resync.unwrap_or(0)
    }

    // optional uint32 udp_packets = 6;

    pub fn clear_udp_packets(&mut self) {
        self.udp_packets = ::std::option::Option::None;
    }

    pub fn has_udp_packets(&self) -> bool {
        self.udp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_packets(&mut self, v: u32) {
        self.udp_packets = ::std::option::Option::Some(v);
    }

    pub fn get_udp_packets<'a>(&self) -> u32 {
        self.udp_packets.unwrap_or(0)
    }

    // optional uint32 tcp_packets = 7;

    pub fn clear_tcp_packets(&mut self) {
        self.tcp_packets = ::std::option::Option::None;
    }

    pub fn has_tcp_packets(&self) -> bool {
        self.tcp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_packets(&mut self, v: u32) {
        self.tcp_packets = ::std::option::Option::Some(v);
    }

    pub fn get_tcp_packets<'a>(&self) -> u32 {
        self.tcp_packets.unwrap_or(0)
    }

    // optional float udp_ping_avg = 8;

    pub fn clear_udp_ping_avg(&mut self) {
        self.udp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_udp_ping_avg(&self) -> bool {
        self.udp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_avg(&mut self, v: f32) {
        self.udp_ping_avg = ::std::option::Option::Some(v);
    }

    pub fn get_udp_ping_avg<'a>(&self) -> f32 {
        self.udp_ping_avg.unwrap_or(0.)
    }

    // optional float udp_ping_var = 9;

    pub fn clear_udp_ping_var(&mut self) {
        self.udp_ping_var = ::std::option::Option::None;
    }

    pub fn has_udp_ping_var(&self) -> bool {
        self.udp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_var(&mut self, v: f32) {
        self.udp_ping_var = ::std::option::Option::Some(v);
    }

    pub fn get_udp_ping_var<'a>(&self) -> f32 {
        self.udp_ping_var.unwrap_or(0.)
    }

    // optional float tcp_ping_avg = 10;

    pub fn clear_tcp_ping_avg(&mut self) {
        self.tcp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_avg(&self) -> bool {
        self.tcp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_avg(&mut self, v: f32) {
        self.tcp_ping_avg = ::std::option::Option::Some(v);
    }

    pub fn get_tcp_ping_avg<'a>(&self) -> f32 {
        self.tcp_ping_avg.unwrap_or(0.)
    }

    // optional float tcp_ping_var = 11;

    pub fn clear_tcp_ping_var(&mut self) {
        self.tcp_ping_var = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_var(&self) -> bool {
        self.tcp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_var(&mut self, v: f32) {
        self.tcp_ping_var = ::std::option::Option::Some(v);
    }

    pub fn get_tcp_ping_var<'a>(&self) -> f32 {
        self.tcp_ping_var.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Ping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.good = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.late = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.lost = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.resync = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.udp_packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.tcp_packets = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.udp_ping_avg = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.udp_ping_var = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.tcp_ping_avg = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.tcp_ping_var = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.timestamp.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.good.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.late.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lost.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.resync.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.udp_packets.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tcp_packets.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.udp_ping_avg.is_some() {
            my_size += 5;
        };
        if self.udp_ping_var.is_some() {
            my_size += 5;
        };
        if self.tcp_ping_avg.is_some() {
            my_size += 5;
        };
        if self.tcp_ping_var.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.good {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.late {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.lost {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.resync {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.udp_packets {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.tcp_packets {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.udp_ping_avg {
            try!(os.write_float(8, v));
        };
        if let Some(v) = self.udp_ping_var {
            try!(os.write_float(9, v));
        };
        if let Some(v) = self.tcp_ping_avg {
            try!(os.write_float(10, v));
        };
        if let Some(v) = self.tcp_ping_var {
            try!(os.write_float(11, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Ping>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Ping {
    fn new() -> Ping {
        Ping::new()
    }

    fn descriptor_static(_: ::std::option::Option<Ping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "timestamp",
                    Ping::has_timestamp,
                    Ping::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "good",
                    Ping::has_good,
                    Ping::get_good,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "late",
                    Ping::has_late,
                    Ping::get_late,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "lost",
                    Ping::has_lost,
                    Ping::get_lost,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "resync",
                    Ping::has_resync,
                    Ping::get_resync,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "udp_packets",
                    Ping::has_udp_packets,
                    Ping::get_udp_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "tcp_packets",
                    Ping::has_tcp_packets,
                    Ping::get_tcp_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "udp_ping_avg",
                    Ping::has_udp_ping_avg,
                    Ping::get_udp_ping_avg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "udp_ping_var",
                    Ping::has_udp_ping_var,
                    Ping::get_udp_ping_var,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "tcp_ping_avg",
                    Ping::has_tcp_ping_avg,
                    Ping::get_tcp_ping_avg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "tcp_ping_var",
                    Ping::has_tcp_ping_var,
                    Ping::get_tcp_ping_var,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ping>(
                    "Ping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Ping {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_good();
        self.clear_late();
        self.clear_lost();
        self.clear_resync();
        self.clear_udp_packets();
        self.clear_tcp_packets();
        self.clear_udp_ping_avg();
        self.clear_udp_ping_var();
        self.clear_tcp_ping_avg();
        self.clear_tcp_ping_var();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Ping {
    fn eq(&self, other: &Ping) -> bool {
        self.timestamp == other.timestamp &&
        self.good == other.good &&
        self.late == other.late &&
        self.lost == other.lost &&
        self.resync == other.resync &&
        self.udp_packets == other.udp_packets &&
        self.tcp_packets == other.tcp_packets &&
        self.udp_ping_avg == other.udp_ping_avg &&
        self.udp_ping_var == other.udp_ping_var &&
        self.tcp_ping_avg == other.tcp_ping_avg &&
        self.tcp_ping_var == other.tcp_ping_var &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Ping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Reject {
    // message fields
    field_type: ::std::option::Option<Reject_RejectType>,
    reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Reject {}

impl Reject {
    pub fn new() -> Reject {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Reject {
        static mut instance: ::protobuf::lazy::Lazy<Reject> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Reject,
        };
        unsafe {
            instance.get(|| {
                Reject {
                    field_type: ::std::option::Option::None,
                    reason: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .MumbleProto.Reject.RejectType type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Reject_RejectType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Reject_RejectType {
        self.field_type.unwrap_or(Reject_RejectType::None)
    }

    // optional string reason = 2;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        };
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason<'a>(&'a self) -> &'a str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Reject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.reason.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.reason.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Reject>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Reject {
    fn new() -> Reject {
        Reject::new()
    }

    fn descriptor_static(_: ::std::option::Option<Reject>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Reject::has_field_type,
                    Reject::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "reason",
                    Reject::has_reason,
                    Reject::get_reason,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Reject>(
                    "Reject",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Reject {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Reject {
    fn eq(&self, other: &Reject) -> bool {
        self.field_type == other.field_type &&
        self.reason == other.reason &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Reject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Reject_RejectType {
    None = 0,
    WrongVersion = 1,
    InvalidUsername = 2,
    WrongUserPW = 3,
    WrongServerPW = 4,
    UsernameInUse = 5,
    ServerFull = 6,
    NoCertificate = 7,
    AuthenticatorFail = 8,
}

impl ::protobuf::ProtobufEnum for Reject_RejectType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Reject_RejectType> {
        match value {
            0 => ::std::option::Option::Some(Reject_RejectType::None),
            1 => ::std::option::Option::Some(Reject_RejectType::WrongVersion),
            2 => ::std::option::Option::Some(Reject_RejectType::InvalidUsername),
            3 => ::std::option::Option::Some(Reject_RejectType::WrongUserPW),
            4 => ::std::option::Option::Some(Reject_RejectType::WrongServerPW),
            5 => ::std::option::Option::Some(Reject_RejectType::UsernameInUse),
            6 => ::std::option::Option::Some(Reject_RejectType::ServerFull),
            7 => ::std::option::Option::Some(Reject_RejectType::NoCertificate),
            8 => ::std::option::Option::Some(Reject_RejectType::AuthenticatorFail),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Reject_RejectType] = &[
            Reject_RejectType::None,
            Reject_RejectType::WrongVersion,
            Reject_RejectType::InvalidUsername,
            Reject_RejectType::WrongUserPW,
            Reject_RejectType::WrongServerPW,
            Reject_RejectType::UsernameInUse,
            Reject_RejectType::ServerFull,
            Reject_RejectType::NoCertificate,
            Reject_RejectType::AuthenticatorFail,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Reject_RejectType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Reject_RejectType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Reject_RejectType {
}

#[derive(Clone,Default)]
pub struct ServerSync {
    // message fields
    session: ::std::option::Option<u32>,
    max_bandwidth: ::std::option::Option<u32>,
    welcome_text: ::protobuf::SingularField<::std::string::String>,
    permissions: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServerSync {}

impl ServerSync {
    pub fn new() -> ServerSync {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServerSync {
        static mut instance: ::protobuf::lazy::Lazy<ServerSync> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerSync,
        };
        unsafe {
            instance.get(|| {
                ServerSync {
                    session: ::std::option::Option::None,
                    max_bandwidth: ::std::option::Option::None,
                    welcome_text: ::protobuf::SingularField::none(),
                    permissions: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 session = 1;

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    pub fn get_session<'a>(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    // optional uint32 max_bandwidth = 2;

    pub fn clear_max_bandwidth(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
    }

    pub fn has_max_bandwidth(&self) -> bool {
        self.max_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bandwidth(&mut self, v: u32) {
        self.max_bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_max_bandwidth<'a>(&self) -> u32 {
        self.max_bandwidth.unwrap_or(0)
    }

    // optional string welcome_text = 3;

    pub fn clear_welcome_text(&mut self) {
        self.welcome_text.clear();
    }

    pub fn has_welcome_text(&self) -> bool {
        self.welcome_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome_text(&mut self, v: ::std::string::String) {
        self.welcome_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome_text<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.welcome_text.is_none() {
            self.welcome_text.set_default();
        };
        self.welcome_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome_text(&mut self) -> ::std::string::String {
        self.welcome_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_welcome_text<'a>(&'a self) -> &'a str {
        match self.welcome_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 permissions = 4;

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u64) {
        self.permissions = ::std::option::Option::Some(v);
    }

    pub fn get_permissions<'a>(&self) -> u64 {
        self.permissions.unwrap_or(0)
    }
}

impl ::protobuf::Message for ServerSync {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.max_bandwidth = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.welcome_text));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.permissions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.max_bandwidth.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.welcome_text.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.permissions.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.max_bandwidth {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.welcome_text.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.permissions {
            try!(os.write_uint64(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ServerSync>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServerSync {
    fn new() -> ServerSync {
        ServerSync::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServerSync>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "session",
                    ServerSync::has_session,
                    ServerSync::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "max_bandwidth",
                    ServerSync::has_max_bandwidth,
                    ServerSync::get_max_bandwidth,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "welcome_text",
                    ServerSync::has_welcome_text,
                    ServerSync::get_welcome_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "permissions",
                    ServerSync::has_permissions,
                    ServerSync::get_permissions,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerSync>(
                    "ServerSync",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServerSync {
    fn clear(&mut self) {
        self.clear_session();
        self.clear_max_bandwidth();
        self.clear_welcome_text();
        self.clear_permissions();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ServerSync {
    fn eq(&self, other: &ServerSync) -> bool {
        self.session == other.session &&
        self.max_bandwidth == other.max_bandwidth &&
        self.welcome_text == other.welcome_text &&
        self.permissions == other.permissions &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ServerSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ChannelRemove {
    // message fields
    channel_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ChannelRemove {}

impl ChannelRemove {
    pub fn new() -> ChannelRemove {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ChannelRemove {
        static mut instance: ::protobuf::lazy::Lazy<ChannelRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelRemove,
        };
        unsafe {
            instance.get(|| {
                ChannelRemove {
                    channel_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for ChannelRemove {
    fn is_initialized(&self) -> bool {
        if self.channel_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ChannelRemove>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ChannelRemove {
    fn new() -> ChannelRemove {
        ChannelRemove::new()
    }

    fn descriptor_static(_: ::std::option::Option<ChannelRemove>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    ChannelRemove::has_channel_id,
                    ChannelRemove::get_channel_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelRemove>(
                    "ChannelRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ChannelRemove {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ChannelRemove {
    fn eq(&self, other: &ChannelRemove) -> bool {
        self.channel_id == other.channel_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ChannelRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ChannelState {
    // message fields
    channel_id: ::std::option::Option<u32>,
    parent: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    links: ::std::vec::Vec<u32>,
    description: ::protobuf::SingularField<::std::string::String>,
    links_add: ::std::vec::Vec<u32>,
    links_remove: ::std::vec::Vec<u32>,
    temporary: ::std::option::Option<bool>,
    position: ::std::option::Option<i32>,
    description_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    max_users: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ChannelState {}

impl ChannelState {
    pub fn new() -> ChannelState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ChannelState {
        static mut instance: ::protobuf::lazy::Lazy<ChannelState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelState,
        };
        unsafe {
            instance.get(|| {
                ChannelState {
                    channel_id: ::std::option::Option::None,
                    parent: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    links: ::std::vec::Vec::new(),
                    description: ::protobuf::SingularField::none(),
                    links_add: ::std::vec::Vec::new(),
                    links_remove: ::std::vec::Vec::new(),
                    temporary: ::std::option::Option::None,
                    position: ::std::option::Option::None,
                    description_hash: ::protobuf::SingularField::none(),
                    max_users: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // optional uint32 parent = 2;

    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: u32) {
        self.parent = ::std::option::Option::Some(v);
    }

    pub fn get_parent<'a>(&self) -> u32 {
        self.parent.unwrap_or(0)
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated uint32 links = 4;

    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::vec::Vec<u32>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.links, ::std::vec::Vec::new())
    }

    pub fn get_links<'a>(&'a self) -> &'a [u32] {
        &self.links
    }

    // optional string description = 5;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        };
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_description<'a>(&'a self) -> &'a str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated uint32 links_add = 6;

    pub fn clear_links_add(&mut self) {
        self.links_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_links_add(&mut self, v: ::std::vec::Vec<u32>) {
        self.links_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links_add<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.links_add
    }

    // Take field
    pub fn take_links_add(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.links_add, ::std::vec::Vec::new())
    }

    pub fn get_links_add<'a>(&'a self) -> &'a [u32] {
        &self.links_add
    }

    // repeated uint32 links_remove = 7;

    pub fn clear_links_remove(&mut self) {
        self.links_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_links_remove(&mut self, v: ::std::vec::Vec<u32>) {
        self.links_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links_remove<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.links_remove
    }

    // Take field
    pub fn take_links_remove(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.links_remove, ::std::vec::Vec::new())
    }

    pub fn get_links_remove<'a>(&'a self) -> &'a [u32] {
        &self.links_remove
    }

    // optional bool temporary = 8;

    pub fn clear_temporary(&mut self) {
        self.temporary = ::std::option::Option::None;
    }

    pub fn has_temporary(&self) -> bool {
        self.temporary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_temporary(&mut self, v: bool) {
        self.temporary = ::std::option::Option::Some(v);
    }

    pub fn get_temporary<'a>(&self) -> bool {
        self.temporary.unwrap_or(false)
    }

    // optional int32 position = 9;

    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: i32) {
        self.position = ::std::option::Option::Some(v);
    }

    pub fn get_position<'a>(&self) -> i32 {
        self.position.unwrap_or(0i32)
    }

    // optional bytes description_hash = 10;

    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    pub fn has_description_hash(&self) -> bool {
        self.description_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.description_hash.is_none() {
            self.description_hash.set_default();
        };
        self.description_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.description_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_description_hash<'a>(&'a self) -> &'a [u8] {
        match self.description_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 max_users = 11;

    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }

    pub fn get_max_users<'a>(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }
}

impl ::protobuf::Message for ChannelState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.parent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.links));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.links_add));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.links_remove));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.temporary = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.position = ::std::option::Option::Some(tmp);
                },
                10 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.description_hash));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.max_users = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.parent.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.links.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.description.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.links_add.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.links_remove.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.temporary.is_some() {
            my_size += 2;
        };
        for value in self.position.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.description_hash.iter() {
            my_size += ::protobuf::rt::bytes_size(10, &value);
        };
        for value in self.max_users.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.parent {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(3, &v));
        };
        for v in self.links.iter() {
            try!(os.write_uint32(4, *v));
        };
        if let Some(v) = self.description.as_ref() {
            try!(os.write_string(5, &v));
        };
        for v in self.links_add.iter() {
            try!(os.write_uint32(6, *v));
        };
        for v in self.links_remove.iter() {
            try!(os.write_uint32(7, *v));
        };
        if let Some(v) = self.temporary {
            try!(os.write_bool(8, v));
        };
        if let Some(v) = self.position {
            try!(os.write_int32(9, v));
        };
        if let Some(v) = self.description_hash.as_ref() {
            try!(os.write_bytes(10, &v));
        };
        if let Some(v) = self.max_users {
            try!(os.write_uint32(11, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ChannelState>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ChannelState {
    fn new() -> ChannelState {
        ChannelState::new()
    }

    fn descriptor_static(_: ::std::option::Option<ChannelState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    ChannelState::has_channel_id,
                    ChannelState::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "parent",
                    ChannelState::has_parent,
                    ChannelState::get_parent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    ChannelState::has_name,
                    ChannelState::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "links",
                    ChannelState::get_links,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "description",
                    ChannelState::has_description,
                    ChannelState::get_description,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "links_add",
                    ChannelState::get_links_add,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "links_remove",
                    ChannelState::get_links_remove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "temporary",
                    ChannelState::has_temporary,
                    ChannelState::get_temporary,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "position",
                    ChannelState::has_position,
                    ChannelState::get_position,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "description_hash",
                    ChannelState::has_description_hash,
                    ChannelState::get_description_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "max_users",
                    ChannelState::has_max_users,
                    ChannelState::get_max_users,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelState>(
                    "ChannelState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ChannelState {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_parent();
        self.clear_name();
        self.clear_links();
        self.clear_description();
        self.clear_links_add();
        self.clear_links_remove();
        self.clear_temporary();
        self.clear_position();
        self.clear_description_hash();
        self.clear_max_users();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ChannelState {
    fn eq(&self, other: &ChannelState) -> bool {
        self.channel_id == other.channel_id &&
        self.parent == other.parent &&
        self.name == other.name &&
        self.links == other.links &&
        self.description == other.description &&
        self.links_add == other.links_add &&
        self.links_remove == other.links_remove &&
        self.temporary == other.temporary &&
        self.position == other.position &&
        self.description_hash == other.description_hash &&
        self.max_users == other.max_users &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ChannelState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UserRemove {
    // message fields
    session: ::std::option::Option<u32>,
    actor: ::std::option::Option<u32>,
    reason: ::protobuf::SingularField<::std::string::String>,
    ban: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UserRemove {}

impl UserRemove {
    pub fn new() -> UserRemove {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UserRemove {
        static mut instance: ::protobuf::lazy::Lazy<UserRemove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserRemove,
        };
        unsafe {
            instance.get(|| {
                UserRemove {
                    session: ::std::option::Option::None,
                    actor: ::std::option::Option::None,
                    reason: ::protobuf::SingularField::none(),
                    ban: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 session = 1;

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    pub fn get_session<'a>(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    // optional uint32 actor = 2;

    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    pub fn get_actor<'a>(&self) -> u32 {
        self.actor.unwrap_or(0)
    }

    // optional string reason = 3;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        };
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason<'a>(&'a self) -> &'a str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool ban = 4;

    pub fn clear_ban(&mut self) {
        self.ban = ::std::option::Option::None;
    }

    pub fn has_ban(&self) -> bool {
        self.ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban(&mut self, v: bool) {
        self.ban = ::std::option::Option::Some(v);
    }

    pub fn get_ban<'a>(&self) -> bool {
        self.ban.unwrap_or(false)
    }
}

impl ::protobuf::Message for UserRemove {
    fn is_initialized(&self) -> bool {
        if self.session.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.ban = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.actor.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.reason.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.ban.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.actor {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.reason.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.ban {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UserRemove>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UserRemove {
    fn new() -> UserRemove {
        UserRemove::new()
    }

    fn descriptor_static(_: ::std::option::Option<UserRemove>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "session",
                    UserRemove::has_session,
                    UserRemove::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "actor",
                    UserRemove::has_actor,
                    UserRemove::get_actor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "reason",
                    UserRemove::has_reason,
                    UserRemove::get_reason,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "ban",
                    UserRemove::has_ban,
                    UserRemove::get_ban,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserRemove>(
                    "UserRemove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UserRemove {
    fn clear(&mut self) {
        self.clear_session();
        self.clear_actor();
        self.clear_reason();
        self.clear_ban();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UserRemove {
    fn eq(&self, other: &UserRemove) -> bool {
        self.session == other.session &&
        self.actor == other.actor &&
        self.reason == other.reason &&
        self.ban == other.ban &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UserRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UserState {
    // message fields
    session: ::std::option::Option<u32>,
    actor: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    user_id: ::std::option::Option<u32>,
    channel_id: ::std::option::Option<u32>,
    mute: ::std::option::Option<bool>,
    deaf: ::std::option::Option<bool>,
    suppress: ::std::option::Option<bool>,
    self_mute: ::std::option::Option<bool>,
    self_deaf: ::std::option::Option<bool>,
    texture: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    plugin_context: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    plugin_identity: ::protobuf::SingularField<::std::string::String>,
    comment: ::protobuf::SingularField<::std::string::String>,
    hash: ::protobuf::SingularField<::std::string::String>,
    comment_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    texture_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    priority_speaker: ::std::option::Option<bool>,
    recording: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UserState {}

impl UserState {
    pub fn new() -> UserState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UserState {
        static mut instance: ::protobuf::lazy::Lazy<UserState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserState,
        };
        unsafe {
            instance.get(|| {
                UserState {
                    session: ::std::option::Option::None,
                    actor: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    user_id: ::std::option::Option::None,
                    channel_id: ::std::option::Option::None,
                    mute: ::std::option::Option::None,
                    deaf: ::std::option::Option::None,
                    suppress: ::std::option::Option::None,
                    self_mute: ::std::option::Option::None,
                    self_deaf: ::std::option::Option::None,
                    texture: ::protobuf::SingularField::none(),
                    plugin_context: ::protobuf::SingularField::none(),
                    plugin_identity: ::protobuf::SingularField::none(),
                    comment: ::protobuf::SingularField::none(),
                    hash: ::protobuf::SingularField::none(),
                    comment_hash: ::protobuf::SingularField::none(),
                    texture_hash: ::protobuf::SingularField::none(),
                    priority_speaker: ::std::option::Option::None,
                    recording: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 session = 1;

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    pub fn get_session<'a>(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    // optional uint32 actor = 2;

    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    pub fn get_actor<'a>(&self) -> u32 {
        self.actor.unwrap_or(0)
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 user_id = 4;

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    pub fn get_user_id<'a>(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }

    // optional uint32 channel_id = 5;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // optional bool mute = 6;

    pub fn clear_mute(&mut self) {
        self.mute = ::std::option::Option::None;
    }

    pub fn has_mute(&self) -> bool {
        self.mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mute(&mut self, v: bool) {
        self.mute = ::std::option::Option::Some(v);
    }

    pub fn get_mute<'a>(&self) -> bool {
        self.mute.unwrap_or(false)
    }

    // optional bool deaf = 7;

    pub fn clear_deaf(&mut self) {
        self.deaf = ::std::option::Option::None;
    }

    pub fn has_deaf(&self) -> bool {
        self.deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaf(&mut self, v: bool) {
        self.deaf = ::std::option::Option::Some(v);
    }

    pub fn get_deaf<'a>(&self) -> bool {
        self.deaf.unwrap_or(false)
    }

    // optional bool suppress = 8;

    pub fn clear_suppress(&mut self) {
        self.suppress = ::std::option::Option::None;
    }

    pub fn has_suppress(&self) -> bool {
        self.suppress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppress(&mut self, v: bool) {
        self.suppress = ::std::option::Option::Some(v);
    }

    pub fn get_suppress<'a>(&self) -> bool {
        self.suppress.unwrap_or(false)
    }

    // optional bool self_mute = 9;

    pub fn clear_self_mute(&mut self) {
        self.self_mute = ::std::option::Option::None;
    }

    pub fn has_self_mute(&self) -> bool {
        self.self_mute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_mute(&mut self, v: bool) {
        self.self_mute = ::std::option::Option::Some(v);
    }

    pub fn get_self_mute<'a>(&self) -> bool {
        self.self_mute.unwrap_or(false)
    }

    // optional bool self_deaf = 10;

    pub fn clear_self_deaf(&mut self) {
        self.self_deaf = ::std::option::Option::None;
    }

    pub fn has_self_deaf(&self) -> bool {
        self.self_deaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_deaf(&mut self, v: bool) {
        self.self_deaf = ::std::option::Option::Some(v);
    }

    pub fn get_self_deaf<'a>(&self) -> bool {
        self.self_deaf.unwrap_or(false)
    }

    // optional bytes texture = 11;

    pub fn clear_texture(&mut self) {
        self.texture.clear();
    }

    pub fn has_texture(&self) -> bool {
        self.texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.texture.is_none() {
            self.texture.set_default();
        };
        self.texture.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture(&mut self) -> ::std::vec::Vec<u8> {
        self.texture.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_texture<'a>(&'a self) -> &'a [u8] {
        match self.texture.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes plugin_context = 12;

    pub fn clear_plugin_context(&mut self) {
        self.plugin_context.clear();
    }

    pub fn has_plugin_context(&self) -> bool {
        self.plugin_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_context(&mut self, v: ::std::vec::Vec<u8>) {
        self.plugin_context = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_context<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.plugin_context.is_none() {
            self.plugin_context.set_default();
        };
        self.plugin_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_context(&mut self) -> ::std::vec::Vec<u8> {
        self.plugin_context.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_plugin_context<'a>(&'a self) -> &'a [u8] {
        match self.plugin_context.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string plugin_identity = 13;

    pub fn clear_plugin_identity(&mut self) {
        self.plugin_identity.clear();
    }

    pub fn has_plugin_identity(&self) -> bool {
        self.plugin_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_identity(&mut self, v: ::std::string::String) {
        self.plugin_identity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_identity<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.plugin_identity.is_none() {
            self.plugin_identity.set_default();
        };
        self.plugin_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_identity(&mut self) -> ::std::string::String {
        self.plugin_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_plugin_identity<'a>(&'a self) -> &'a str {
        match self.plugin_identity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string comment = 14;

    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.comment.is_none() {
            self.comment.set_default();
        };
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_comment<'a>(&'a self) -> &'a str {
        match self.comment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hash = 15;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hash.is_none() {
            self.hash.set_default();
        };
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hash<'a>(&'a self) -> &'a str {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes comment_hash = 16;

    pub fn clear_comment_hash(&mut self) {
        self.comment_hash.clear();
    }

    pub fn has_comment_hash(&self) -> bool {
        self.comment_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.comment_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment_hash<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.comment_hash.is_none() {
            self.comment_hash.set_default();
        };
        self.comment_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.comment_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_comment_hash<'a>(&'a self) -> &'a [u8] {
        match self.comment_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes texture_hash = 17;

    pub fn clear_texture_hash(&mut self) {
        self.texture_hash.clear();
    }

    pub fn has_texture_hash(&self) -> bool {
        self.texture_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.texture_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture_hash<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.texture_hash.is_none() {
            self.texture_hash.set_default();
        };
        self.texture_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.texture_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_texture_hash<'a>(&'a self) -> &'a [u8] {
        match self.texture_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool priority_speaker = 18;

    pub fn clear_priority_speaker(&mut self) {
        self.priority_speaker = ::std::option::Option::None;
    }

    pub fn has_priority_speaker(&self) -> bool {
        self.priority_speaker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_speaker(&mut self, v: bool) {
        self.priority_speaker = ::std::option::Option::Some(v);
    }

    pub fn get_priority_speaker<'a>(&self) -> bool {
        self.priority_speaker.unwrap_or(false)
    }

    // optional bool recording = 19;

    pub fn clear_recording(&mut self) {
        self.recording = ::std::option::Option::None;
    }

    pub fn has_recording(&self) -> bool {
        self.recording.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recording(&mut self, v: bool) {
        self.recording = ::std::option::Option::Some(v);
    }

    pub fn get_recording<'a>(&self) -> bool {
        self.recording.unwrap_or(false)
    }
}

impl ::protobuf::Message for UserState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.actor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.mute = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.deaf = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.suppress = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.self_mute = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.self_deaf = ::std::option::Option::Some(tmp);
                },
                11 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.texture));
                },
                12 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.plugin_context));
                },
                13 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.plugin_identity));
                },
                14 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.comment));
                },
                15 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hash));
                },
                16 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.comment_hash));
                },
                17 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.texture_hash));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.priority_speaker = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.recording = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.actor.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.user_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.mute.is_some() {
            my_size += 2;
        };
        if self.deaf.is_some() {
            my_size += 2;
        };
        if self.suppress.is_some() {
            my_size += 2;
        };
        if self.self_mute.is_some() {
            my_size += 2;
        };
        if self.self_deaf.is_some() {
            my_size += 2;
        };
        for value in self.texture.iter() {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        for value in self.plugin_context.iter() {
            my_size += ::protobuf::rt::bytes_size(12, &value);
        };
        for value in self.plugin_identity.iter() {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in self.comment.iter() {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in self.hash.iter() {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in self.comment_hash.iter() {
            my_size += ::protobuf::rt::bytes_size(16, &value);
        };
        for value in self.texture_hash.iter() {
            my_size += ::protobuf::rt::bytes_size(17, &value);
        };
        if self.priority_speaker.is_some() {
            my_size += 3;
        };
        if self.recording.is_some() {
            my_size += 3;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.actor {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.user_id {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.mute {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.deaf {
            try!(os.write_bool(7, v));
        };
        if let Some(v) = self.suppress {
            try!(os.write_bool(8, v));
        };
        if let Some(v) = self.self_mute {
            try!(os.write_bool(9, v));
        };
        if let Some(v) = self.self_deaf {
            try!(os.write_bool(10, v));
        };
        if let Some(v) = self.texture.as_ref() {
            try!(os.write_bytes(11, &v));
        };
        if let Some(v) = self.plugin_context.as_ref() {
            try!(os.write_bytes(12, &v));
        };
        if let Some(v) = self.plugin_identity.as_ref() {
            try!(os.write_string(13, &v));
        };
        if let Some(v) = self.comment.as_ref() {
            try!(os.write_string(14, &v));
        };
        if let Some(v) = self.hash.as_ref() {
            try!(os.write_string(15, &v));
        };
        if let Some(v) = self.comment_hash.as_ref() {
            try!(os.write_bytes(16, &v));
        };
        if let Some(v) = self.texture_hash.as_ref() {
            try!(os.write_bytes(17, &v));
        };
        if let Some(v) = self.priority_speaker {
            try!(os.write_bool(18, v));
        };
        if let Some(v) = self.recording {
            try!(os.write_bool(19, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UserState>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UserState {
    fn new() -> UserState {
        UserState::new()
    }

    fn descriptor_static(_: ::std::option::Option<UserState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "session",
                    UserState::has_session,
                    UserState::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "actor",
                    UserState::has_actor,
                    UserState::get_actor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    UserState::has_name,
                    UserState::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "user_id",
                    UserState::has_user_id,
                    UserState::get_user_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    UserState::has_channel_id,
                    UserState::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "mute",
                    UserState::has_mute,
                    UserState::get_mute,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "deaf",
                    UserState::has_deaf,
                    UserState::get_deaf,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "suppress",
                    UserState::has_suppress,
                    UserState::get_suppress,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "self_mute",
                    UserState::has_self_mute,
                    UserState::get_self_mute,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "self_deaf",
                    UserState::has_self_deaf,
                    UserState::get_self_deaf,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "texture",
                    UserState::has_texture,
                    UserState::get_texture,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "plugin_context",
                    UserState::has_plugin_context,
                    UserState::get_plugin_context,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "plugin_identity",
                    UserState::has_plugin_identity,
                    UserState::get_plugin_identity,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "comment",
                    UserState::has_comment,
                    UserState::get_comment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hash",
                    UserState::has_hash,
                    UserState::get_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "comment_hash",
                    UserState::has_comment_hash,
                    UserState::get_comment_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "texture_hash",
                    UserState::has_texture_hash,
                    UserState::get_texture_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "priority_speaker",
                    UserState::has_priority_speaker,
                    UserState::get_priority_speaker,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "recording",
                    UserState::has_recording,
                    UserState::get_recording,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserState>(
                    "UserState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UserState {
    fn clear(&mut self) {
        self.clear_session();
        self.clear_actor();
        self.clear_name();
        self.clear_user_id();
        self.clear_channel_id();
        self.clear_mute();
        self.clear_deaf();
        self.clear_suppress();
        self.clear_self_mute();
        self.clear_self_deaf();
        self.clear_texture();
        self.clear_plugin_context();
        self.clear_plugin_identity();
        self.clear_comment();
        self.clear_hash();
        self.clear_comment_hash();
        self.clear_texture_hash();
        self.clear_priority_speaker();
        self.clear_recording();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UserState {
    fn eq(&self, other: &UserState) -> bool {
        self.session == other.session &&
        self.actor == other.actor &&
        self.name == other.name &&
        self.user_id == other.user_id &&
        self.channel_id == other.channel_id &&
        self.mute == other.mute &&
        self.deaf == other.deaf &&
        self.suppress == other.suppress &&
        self.self_mute == other.self_mute &&
        self.self_deaf == other.self_deaf &&
        self.texture == other.texture &&
        self.plugin_context == other.plugin_context &&
        self.plugin_identity == other.plugin_identity &&
        self.comment == other.comment &&
        self.hash == other.hash &&
        self.comment_hash == other.comment_hash &&
        self.texture_hash == other.texture_hash &&
        self.priority_speaker == other.priority_speaker &&
        self.recording == other.recording &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UserState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct BanList {
    // message fields
    bans: ::protobuf::RepeatedField<BanList_BanEntry>,
    query: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for BanList {}

impl BanList {
    pub fn new() -> BanList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static BanList {
        static mut instance: ::protobuf::lazy::Lazy<BanList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BanList,
        };
        unsafe {
            instance.get(|| {
                BanList {
                    bans: ::protobuf::RepeatedField::new(),
                    query: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .MumbleProto.BanList.BanEntry bans = 1;

    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::protobuf::RepeatedField<BanList_BanEntry>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<BanList_BanEntry> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::protobuf::RepeatedField<BanList_BanEntry> {
        ::std::mem::replace(&mut self.bans, ::protobuf::RepeatedField::new())
    }

    pub fn get_bans<'a>(&'a self) -> &'a [BanList_BanEntry] {
        &self.bans
    }

    // optional bool query = 2;

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }

    pub fn get_query<'a>(&self) -> bool {
        self.query.unwrap_or(false)
    }
}

impl ::protobuf::Message for BanList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bans));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.query = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.bans.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.query.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.bans.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.query {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<BanList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for BanList {
    fn new() -> BanList {
        BanList::new()
    }

    fn descriptor_static(_: ::std::option::Option<BanList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "bans",
                    BanList::get_bans,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "query",
                    BanList::has_query,
                    BanList::get_query,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BanList>(
                    "BanList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for BanList {
    fn clear(&mut self) {
        self.clear_bans();
        self.clear_query();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for BanList {
    fn eq(&self, other: &BanList) -> bool {
        self.bans == other.bans &&
        self.query == other.query &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for BanList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct BanList_BanEntry {
    // message fields
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mask: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    hash: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    start: ::protobuf::SingularField<::std::string::String>,
    duration: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for BanList_BanEntry {}

impl BanList_BanEntry {
    pub fn new() -> BanList_BanEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static BanList_BanEntry {
        static mut instance: ::protobuf::lazy::Lazy<BanList_BanEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BanList_BanEntry,
        };
        unsafe {
            instance.get(|| {
                BanList_BanEntry {
                    address: ::protobuf::SingularField::none(),
                    mask: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    hash: ::protobuf::SingularField::none(),
                    reason: ::protobuf::SingularField::none(),
                    start: ::protobuf::SingularField::none(),
                    duration: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        };
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_address<'a>(&'a self) -> &'a [u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // required uint32 mask = 2;

    pub fn clear_mask(&mut self) {
        self.mask = ::std::option::Option::None;
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: u32) {
        self.mask = ::std::option::Option::Some(v);
    }

    pub fn get_mask<'a>(&self) -> u32 {
        self.mask.unwrap_or(0)
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hash = 4;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hash.is_none() {
            self.hash.set_default();
        };
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        self.hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hash<'a>(&'a self) -> &'a str {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string reason = 5;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        };
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason<'a>(&'a self) -> &'a str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string start = 6;

    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::std::string::String) {
        self.start = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.start.is_none() {
            self.start.set_default();
        };
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> ::std::string::String {
        self.start.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_start<'a>(&'a self) -> &'a str {
        match self.start.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 duration = 7;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration<'a>(&self) -> u32 {
        self.duration.unwrap_or(0)
    }
}

impl ::protobuf::Message for BanList_BanEntry {
    fn is_initialized(&self) -> bool {
        if self.address.is_none() {
            return false;
        };
        if self.mask.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.mask = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hash));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.start));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.address.iter() {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in self.mask.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.hash.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.reason.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.start.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.duration.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.address.as_ref() {
            try!(os.write_bytes(1, &v));
        };
        if let Some(v) = self.mask {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.hash.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.reason.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.start.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.duration {
            try!(os.write_uint32(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<BanList_BanEntry>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for BanList_BanEntry {
    fn new() -> BanList_BanEntry {
        BanList_BanEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<BanList_BanEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "address",
                    BanList_BanEntry::has_address,
                    BanList_BanEntry::get_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "mask",
                    BanList_BanEntry::has_mask,
                    BanList_BanEntry::get_mask,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    BanList_BanEntry::has_name,
                    BanList_BanEntry::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hash",
                    BanList_BanEntry::has_hash,
                    BanList_BanEntry::get_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "reason",
                    BanList_BanEntry::has_reason,
                    BanList_BanEntry::get_reason,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "start",
                    BanList_BanEntry::has_start,
                    BanList_BanEntry::get_start,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "duration",
                    BanList_BanEntry::has_duration,
                    BanList_BanEntry::get_duration,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BanList_BanEntry>(
                    "BanList_BanEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for BanList_BanEntry {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_mask();
        self.clear_name();
        self.clear_hash();
        self.clear_reason();
        self.clear_start();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for BanList_BanEntry {
    fn eq(&self, other: &BanList_BanEntry) -> bool {
        self.address == other.address &&
        self.mask == other.mask &&
        self.name == other.name &&
        self.hash == other.hash &&
        self.reason == other.reason &&
        self.start == other.start &&
        self.duration == other.duration &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for BanList_BanEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TextMessage {
    // message fields
    actor: ::std::option::Option<u32>,
    session: ::std::vec::Vec<u32>,
    channel_id: ::std::vec::Vec<u32>,
    tree_id: ::std::vec::Vec<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TextMessage {}

impl TextMessage {
    pub fn new() -> TextMessage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TextMessage {
        static mut instance: ::protobuf::lazy::Lazy<TextMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TextMessage,
        };
        unsafe {
            instance.get(|| {
                TextMessage {
                    actor: ::std::option::Option::None,
                    session: ::std::vec::Vec::new(),
                    channel_id: ::std::vec::Vec::new(),
                    tree_id: ::std::vec::Vec::new(),
                    message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 actor = 1;

    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u32) {
        self.actor = ::std::option::Option::Some(v);
    }

    pub fn get_actor<'a>(&self) -> u32 {
        self.actor.unwrap_or(0)
    }

    // repeated uint32 session = 2;

    pub fn clear_session(&mut self) {
        self.session.clear();
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::vec::Vec<u32>) {
        self.session = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.session
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session, ::std::vec::Vec::new())
    }

    pub fn get_session<'a>(&'a self) -> &'a [u32] {
        &self.session
    }

    // repeated uint32 channel_id = 3;

    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_id<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.channel_id, ::std::vec::Vec::new())
    }

    pub fn get_channel_id<'a>(&'a self) -> &'a [u32] {
        &self.channel_id
    }

    // repeated uint32 tree_id = 4;

    pub fn clear_tree_id(&mut self) {
        self.tree_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.tree_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_id<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.tree_id
    }

    // Take field
    pub fn take_tree_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tree_id, ::std::vec::Vec::new())
    }

    pub fn get_tree_id<'a>(&'a self) -> &'a [u32] {
        &self.tree_id
    }

    // required string message = 5;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TextMessage {
    fn is_initialized(&self) -> bool {
        if self.message.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.actor = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.channel_id));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tree_id));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.actor.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tree_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.actor {
            try!(os.write_uint32(1, v));
        };
        for v in self.session.iter() {
            try!(os.write_uint32(2, *v));
        };
        for v in self.channel_id.iter() {
            try!(os.write_uint32(3, *v));
        };
        for v in self.tree_id.iter() {
            try!(os.write_uint32(4, *v));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TextMessage>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TextMessage {
    fn new() -> TextMessage {
        TextMessage::new()
    }

    fn descriptor_static(_: ::std::option::Option<TextMessage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "actor",
                    TextMessage::has_actor,
                    TextMessage::get_actor,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "session",
                    TextMessage::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "channel_id",
                    TextMessage::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "tree_id",
                    TextMessage::get_tree_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "message",
                    TextMessage::has_message,
                    TextMessage::get_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TextMessage>(
                    "TextMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TextMessage {
    fn clear(&mut self) {
        self.clear_actor();
        self.clear_session();
        self.clear_channel_id();
        self.clear_tree_id();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TextMessage {
    fn eq(&self, other: &TextMessage) -> bool {
        self.actor == other.actor &&
        self.session == other.session &&
        self.channel_id == other.channel_id &&
        self.tree_id == other.tree_id &&
        self.message == other.message &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PermissionDenied {
    // message fields
    permission: ::std::option::Option<u32>,
    channel_id: ::std::option::Option<u32>,
    session: ::std::option::Option<u32>,
    reason: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<PermissionDenied_DenyType>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PermissionDenied {}

impl PermissionDenied {
    pub fn new() -> PermissionDenied {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PermissionDenied {
        static mut instance: ::protobuf::lazy::Lazy<PermissionDenied> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PermissionDenied,
        };
        unsafe {
            instance.get(|| {
                PermissionDenied {
                    permission: ::std::option::Option::None,
                    channel_id: ::std::option::Option::None,
                    session: ::std::option::Option::None,
                    reason: ::protobuf::SingularField::none(),
                    field_type: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 permission = 1;

    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u32) {
        self.permission = ::std::option::Option::Some(v);
    }

    pub fn get_permission<'a>(&self) -> u32 {
        self.permission.unwrap_or(0)
    }

    // optional uint32 channel_id = 2;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // optional uint32 session = 3;

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    pub fn get_session<'a>(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    // optional string reason = 4;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        };
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason<'a>(&'a self) -> &'a str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .MumbleProto.PermissionDenied.DenyType type = 5;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PermissionDenied_DenyType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> PermissionDenied_DenyType {
        self.field_type.unwrap_or(PermissionDenied_DenyType::Text)
    }

    // optional string name = 6;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for PermissionDenied {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.permission = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.session = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.permission.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.reason.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.permission {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.session {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.reason.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.field_type {
            try!(os.write_enum(5, v.value()));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(6, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PermissionDenied>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PermissionDenied {
    fn new() -> PermissionDenied {
        PermissionDenied::new()
    }

    fn descriptor_static(_: ::std::option::Option<PermissionDenied>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "permission",
                    PermissionDenied::has_permission,
                    PermissionDenied::get_permission,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    PermissionDenied::has_channel_id,
                    PermissionDenied::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "session",
                    PermissionDenied::has_session,
                    PermissionDenied::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "reason",
                    PermissionDenied::has_reason,
                    PermissionDenied::get_reason,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    PermissionDenied::has_field_type,
                    PermissionDenied::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    PermissionDenied::has_name,
                    PermissionDenied::get_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PermissionDenied>(
                    "PermissionDenied",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PermissionDenied {
    fn clear(&mut self) {
        self.clear_permission();
        self.clear_channel_id();
        self.clear_session();
        self.clear_reason();
        self.clear_field_type();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PermissionDenied {
    fn eq(&self, other: &PermissionDenied) -> bool {
        self.permission == other.permission &&
        self.channel_id == other.channel_id &&
        self.session == other.session &&
        self.reason == other.reason &&
        self.field_type == other.field_type &&
        self.name == other.name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PermissionDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PermissionDenied_DenyType {
    Text = 0,
    Permission = 1,
    SuperUser = 2,
    ChannelName = 3,
    TextTooLong = 4,
    H9K = 5,
    TemporaryChannel = 6,
    MissingCertificate = 7,
    UserName = 8,
    ChannelFull = 9,
    NestingLimit = 10,
}

impl ::protobuf::ProtobufEnum for PermissionDenied_DenyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PermissionDenied_DenyType> {
        match value {
            0 => ::std::option::Option::Some(PermissionDenied_DenyType::Text),
            1 => ::std::option::Option::Some(PermissionDenied_DenyType::Permission),
            2 => ::std::option::Option::Some(PermissionDenied_DenyType::SuperUser),
            3 => ::std::option::Option::Some(PermissionDenied_DenyType::ChannelName),
            4 => ::std::option::Option::Some(PermissionDenied_DenyType::TextTooLong),
            5 => ::std::option::Option::Some(PermissionDenied_DenyType::H9K),
            6 => ::std::option::Option::Some(PermissionDenied_DenyType::TemporaryChannel),
            7 => ::std::option::Option::Some(PermissionDenied_DenyType::MissingCertificate),
            8 => ::std::option::Option::Some(PermissionDenied_DenyType::UserName),
            9 => ::std::option::Option::Some(PermissionDenied_DenyType::ChannelFull),
            10 => ::std::option::Option::Some(PermissionDenied_DenyType::NestingLimit),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PermissionDenied_DenyType] = &[
            PermissionDenied_DenyType::Text,
            PermissionDenied_DenyType::Permission,
            PermissionDenied_DenyType::SuperUser,
            PermissionDenied_DenyType::ChannelName,
            PermissionDenied_DenyType::TextTooLong,
            PermissionDenied_DenyType::H9K,
            PermissionDenied_DenyType::TemporaryChannel,
            PermissionDenied_DenyType::MissingCertificate,
            PermissionDenied_DenyType::UserName,
            PermissionDenied_DenyType::ChannelFull,
            PermissionDenied_DenyType::NestingLimit,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<PermissionDenied_DenyType>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PermissionDenied_DenyType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PermissionDenied_DenyType {
}

#[derive(Clone,Default)]
pub struct ACL {
    // message fields
    channel_id: ::std::option::Option<u32>,
    inherit_acls: ::std::option::Option<bool>,
    groups: ::protobuf::RepeatedField<ACL_ChanGroup>,
    acls: ::protobuf::RepeatedField<ACL_ChanACL>,
    query: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ACL {}

impl ACL {
    pub fn new() -> ACL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL {
        static mut instance: ::protobuf::lazy::Lazy<ACL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL,
        };
        unsafe {
            instance.get(|| {
                ACL {
                    channel_id: ::std::option::Option::None,
                    inherit_acls: ::std::option::Option::None,
                    groups: ::protobuf::RepeatedField::new(),
                    acls: ::protobuf::RepeatedField::new(),
                    query: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // optional bool inherit_acls = 2;

    pub fn clear_inherit_acls(&mut self) {
        self.inherit_acls = ::std::option::Option::None;
    }

    pub fn has_inherit_acls(&self) -> bool {
        self.inherit_acls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit_acls(&mut self, v: bool) {
        self.inherit_acls = ::std::option::Option::Some(v);
    }

    pub fn get_inherit_acls<'a>(&self) -> bool {
        self.inherit_acls.unwrap_or(true)
    }

    // repeated .MumbleProto.ACL.ChanGroup groups = 3;

    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<ACL_ChanGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ACL_ChanGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<ACL_ChanGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_groups<'a>(&'a self) -> &'a [ACL_ChanGroup] {
        &self.groups
    }

    // repeated .MumbleProto.ACL.ChanACL acls = 4;

    pub fn clear_acls(&mut self) {
        self.acls.clear();
    }

    // Param is passed by value, moved
    pub fn set_acls(&mut self, v: ::protobuf::RepeatedField<ACL_ChanACL>) {
        self.acls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_acls<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ACL_ChanACL> {
        &mut self.acls
    }

    // Take field
    pub fn take_acls(&mut self) -> ::protobuf::RepeatedField<ACL_ChanACL> {
        ::std::mem::replace(&mut self.acls, ::protobuf::RepeatedField::new())
    }

    pub fn get_acls<'a>(&'a self) -> &'a [ACL_ChanACL] {
        &self.acls
    }

    // optional bool query = 5;

    pub fn clear_query(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        self.query.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = ::std::option::Option::Some(v);
    }

    pub fn get_query<'a>(&self) -> bool {
        self.query.unwrap_or(false)
    }
}

impl ::protobuf::Message for ACL {
    fn is_initialized(&self) -> bool {
        if self.channel_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.inherit_acls = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.acls));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.query = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.inherit_acls.is_some() {
            my_size += 2;
        };
        for value in self.groups.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.acls.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.query.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.inherit_acls {
            try!(os.write_bool(2, v));
        };
        for v in self.groups.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.acls.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.query {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL {
    fn new() -> ACL {
        ACL::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    ACL::has_channel_id,
                    ACL::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "inherit_acls",
                    ACL::has_inherit_acls,
                    ACL::get_inherit_acls,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "groups",
                    ACL::get_groups,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "acls",
                    ACL::get_acls,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "query",
                    ACL::has_query,
                    ACL::get_query,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL>(
                    "ACL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_inherit_acls();
        self.clear_groups();
        self.clear_acls();
        self.clear_query();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL {
    fn eq(&self, other: &ACL) -> bool {
        self.channel_id == other.channel_id &&
        self.inherit_acls == other.inherit_acls &&
        self.groups == other.groups &&
        self.acls == other.acls &&
        self.query == other.query &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACL_ChanGroup {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    inherited: ::std::option::Option<bool>,
    inherit: ::std::option::Option<bool>,
    inheritable: ::std::option::Option<bool>,
    add: ::std::vec::Vec<u32>,
    remove: ::std::vec::Vec<u32>,
    inherited_members: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ACL_ChanGroup {}

impl ACL_ChanGroup {
    pub fn new() -> ACL_ChanGroup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL_ChanGroup {
        static mut instance: ::protobuf::lazy::Lazy<ACL_ChanGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL_ChanGroup,
        };
        unsafe {
            instance.get(|| {
                ACL_ChanGroup {
                    name: ::protobuf::SingularField::none(),
                    inherited: ::std::option::Option::None,
                    inherit: ::std::option::Option::None,
                    inheritable: ::std::option::Option::None,
                    add: ::std::vec::Vec::new(),
                    remove: ::std::vec::Vec::new(),
                    inherited_members: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool inherited = 2;

    pub fn clear_inherited(&mut self) {
        self.inherited = ::std::option::Option::None;
    }

    pub fn has_inherited(&self) -> bool {
        self.inherited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherited(&mut self, v: bool) {
        self.inherited = ::std::option::Option::Some(v);
    }

    pub fn get_inherited<'a>(&self) -> bool {
        self.inherited.unwrap_or(true)
    }

    // optional bool inherit = 3;

    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }

    pub fn get_inherit<'a>(&self) -> bool {
        self.inherit.unwrap_or(true)
    }

    // optional bool inheritable = 4;

    pub fn clear_inheritable(&mut self) {
        self.inheritable = ::std::option::Option::None;
    }

    pub fn has_inheritable(&self) -> bool {
        self.inheritable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inheritable(&mut self, v: bool) {
        self.inheritable = ::std::option::Option::Some(v);
    }

    pub fn get_inheritable<'a>(&self) -> bool {
        self.inheritable.unwrap_or(true)
    }

    // repeated uint32 add = 5;

    pub fn clear_add(&mut self) {
        self.add.clear();
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: ::std::vec::Vec<u32>) {
        self.add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.add
    }

    // Take field
    pub fn take_add(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.add, ::std::vec::Vec::new())
    }

    pub fn get_add<'a>(&'a self) -> &'a [u32] {
        &self.add
    }

    // repeated uint32 remove = 6;

    pub fn clear_remove(&mut self) {
        self.remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_remove(&mut self, v: ::std::vec::Vec<u32>) {
        self.remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_remove<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.remove
    }

    // Take field
    pub fn take_remove(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.remove, ::std::vec::Vec::new())
    }

    pub fn get_remove<'a>(&'a self) -> &'a [u32] {
        &self.remove
    }

    // repeated uint32 inherited_members = 7;

    pub fn clear_inherited_members(&mut self) {
        self.inherited_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_inherited_members(&mut self, v: ::std::vec::Vec<u32>) {
        self.inherited_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inherited_members<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.inherited_members
    }

    // Take field
    pub fn take_inherited_members(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.inherited_members, ::std::vec::Vec::new())
    }

    pub fn get_inherited_members<'a>(&'a self) -> &'a [u32] {
        &self.inherited_members
    }
}

impl ::protobuf::Message for ACL_ChanGroup {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.inherited = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.inherit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.inheritable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.add));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.remove));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.inherited_members));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.inherited.is_some() {
            my_size += 2;
        };
        if self.inherit.is_some() {
            my_size += 2;
        };
        if self.inheritable.is_some() {
            my_size += 2;
        };
        for value in self.add.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.remove.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.inherited_members.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.inherited {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.inherit {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.inheritable {
            try!(os.write_bool(4, v));
        };
        for v in self.add.iter() {
            try!(os.write_uint32(5, *v));
        };
        for v in self.remove.iter() {
            try!(os.write_uint32(6, *v));
        };
        for v in self.inherited_members.iter() {
            try!(os.write_uint32(7, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL_ChanGroup>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL_ChanGroup {
    fn new() -> ACL_ChanGroup {
        ACL_ChanGroup::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL_ChanGroup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    ACL_ChanGroup::has_name,
                    ACL_ChanGroup::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "inherited",
                    ACL_ChanGroup::has_inherited,
                    ACL_ChanGroup::get_inherited,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "inherit",
                    ACL_ChanGroup::has_inherit,
                    ACL_ChanGroup::get_inherit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "inheritable",
                    ACL_ChanGroup::has_inheritable,
                    ACL_ChanGroup::get_inheritable,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "add",
                    ACL_ChanGroup::get_add,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "remove",
                    ACL_ChanGroup::get_remove,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "inherited_members",
                    ACL_ChanGroup::get_inherited_members,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL_ChanGroup>(
                    "ACL_ChanGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL_ChanGroup {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_inherited();
        self.clear_inherit();
        self.clear_inheritable();
        self.clear_add();
        self.clear_remove();
        self.clear_inherited_members();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL_ChanGroup {
    fn eq(&self, other: &ACL_ChanGroup) -> bool {
        self.name == other.name &&
        self.inherited == other.inherited &&
        self.inherit == other.inherit &&
        self.inheritable == other.inheritable &&
        self.add == other.add &&
        self.remove == other.remove &&
        self.inherited_members == other.inherited_members &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL_ChanGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ACL_ChanACL {
    // message fields
    apply_here: ::std::option::Option<bool>,
    apply_subs: ::std::option::Option<bool>,
    inherited: ::std::option::Option<bool>,
    user_id: ::std::option::Option<u32>,
    group: ::protobuf::SingularField<::std::string::String>,
    grant: ::std::option::Option<u32>,
    deny: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ACL_ChanACL {}

impl ACL_ChanACL {
    pub fn new() -> ACL_ChanACL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ACL_ChanACL {
        static mut instance: ::protobuf::lazy::Lazy<ACL_ChanACL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ACL_ChanACL,
        };
        unsafe {
            instance.get(|| {
                ACL_ChanACL {
                    apply_here: ::std::option::Option::None,
                    apply_subs: ::std::option::Option::None,
                    inherited: ::std::option::Option::None,
                    user_id: ::std::option::Option::None,
                    group: ::protobuf::SingularField::none(),
                    grant: ::std::option::Option::None,
                    deny: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool apply_here = 1;

    pub fn clear_apply_here(&mut self) {
        self.apply_here = ::std::option::Option::None;
    }

    pub fn has_apply_here(&self) -> bool {
        self.apply_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_here(&mut self, v: bool) {
        self.apply_here = ::std::option::Option::Some(v);
    }

    pub fn get_apply_here<'a>(&self) -> bool {
        self.apply_here.unwrap_or(true)
    }

    // optional bool apply_subs = 2;

    pub fn clear_apply_subs(&mut self) {
        self.apply_subs = ::std::option::Option::None;
    }

    pub fn has_apply_subs(&self) -> bool {
        self.apply_subs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apply_subs(&mut self, v: bool) {
        self.apply_subs = ::std::option::Option::Some(v);
    }

    pub fn get_apply_subs<'a>(&self) -> bool {
        self.apply_subs.unwrap_or(true)
    }

    // optional bool inherited = 3;

    pub fn clear_inherited(&mut self) {
        self.inherited = ::std::option::Option::None;
    }

    pub fn has_inherited(&self) -> bool {
        self.inherited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherited(&mut self, v: bool) {
        self.inherited = ::std::option::Option::Some(v);
    }

    pub fn get_inherited<'a>(&self) -> bool {
        self.inherited.unwrap_or(true)
    }

    // optional uint32 user_id = 4;

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    pub fn get_user_id<'a>(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }

    // optional string group = 5;

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        };
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_group<'a>(&'a self) -> &'a str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 grant = 6;

    pub fn clear_grant(&mut self) {
        self.grant = ::std::option::Option::None;
    }

    pub fn has_grant(&self) -> bool {
        self.grant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grant(&mut self, v: u32) {
        self.grant = ::std::option::Option::Some(v);
    }

    pub fn get_grant<'a>(&self) -> u32 {
        self.grant.unwrap_or(0)
    }

    // optional uint32 deny = 7;

    pub fn clear_deny(&mut self) {
        self.deny = ::std::option::Option::None;
    }

    pub fn has_deny(&self) -> bool {
        self.deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny(&mut self, v: u32) {
        self.deny = ::std::option::Option::Some(v);
    }

    pub fn get_deny<'a>(&self) -> u32 {
        self.deny.unwrap_or(0)
    }
}

impl ::protobuf::Message for ACL_ChanACL {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.apply_here = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.apply_subs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.inherited = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.grant = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.deny = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.apply_here.is_some() {
            my_size += 2;
        };
        if self.apply_subs.is_some() {
            my_size += 2;
        };
        if self.inherited.is_some() {
            my_size += 2;
        };
        for value in self.user_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.group.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.grant.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.deny.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.apply_here {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.apply_subs {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.inherited {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.user_id {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.group.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.grant {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.deny {
            try!(os.write_uint32(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ACL_ChanACL>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ACL_ChanACL {
    fn new() -> ACL_ChanACL {
        ACL_ChanACL::new()
    }

    fn descriptor_static(_: ::std::option::Option<ACL_ChanACL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "apply_here",
                    ACL_ChanACL::has_apply_here,
                    ACL_ChanACL::get_apply_here,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "apply_subs",
                    ACL_ChanACL::has_apply_subs,
                    ACL_ChanACL::get_apply_subs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "inherited",
                    ACL_ChanACL::has_inherited,
                    ACL_ChanACL::get_inherited,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "user_id",
                    ACL_ChanACL::has_user_id,
                    ACL_ChanACL::get_user_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "group",
                    ACL_ChanACL::has_group,
                    ACL_ChanACL::get_group,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "grant",
                    ACL_ChanACL::has_grant,
                    ACL_ChanACL::get_grant,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "deny",
                    ACL_ChanACL::has_deny,
                    ACL_ChanACL::get_deny,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ACL_ChanACL>(
                    "ACL_ChanACL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ACL_ChanACL {
    fn clear(&mut self) {
        self.clear_apply_here();
        self.clear_apply_subs();
        self.clear_inherited();
        self.clear_user_id();
        self.clear_group();
        self.clear_grant();
        self.clear_deny();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ACL_ChanACL {
    fn eq(&self, other: &ACL_ChanACL) -> bool {
        self.apply_here == other.apply_here &&
        self.apply_subs == other.apply_subs &&
        self.inherited == other.inherited &&
        self.user_id == other.user_id &&
        self.group == other.group &&
        self.grant == other.grant &&
        self.deny == other.deny &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ACL_ChanACL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct QueryUsers {
    // message fields
    ids: ::std::vec::Vec<u32>,
    names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for QueryUsers {}

impl QueryUsers {
    pub fn new() -> QueryUsers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static QueryUsers {
        static mut instance: ::protobuf::lazy::Lazy<QueryUsers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryUsers,
        };
        unsafe {
            instance.get(|| {
                QueryUsers {
                    ids: ::std::vec::Vec::new(),
                    names: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 ids = 1;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ids, ::std::vec::Vec::new())
    }

    pub fn get_ids<'a>(&'a self) -> &'a [u32] {
        &self.ids
    }

    // repeated string names = 2;

    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    pub fn get_names<'a>(&'a self) -> &'a [::std::string::String] {
        &self.names
    }
}

impl ::protobuf::Message for QueryUsers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ids));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.ids.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.names.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.ids.iter() {
            try!(os.write_uint32(1, *v));
        };
        for v in self.names.iter() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<QueryUsers>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for QueryUsers {
    fn new() -> QueryUsers {
        QueryUsers::new()
    }

    fn descriptor_static(_: ::std::option::Option<QueryUsers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "ids",
                    QueryUsers::get_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "names",
                    QueryUsers::get_names,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryUsers>(
                    "QueryUsers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for QueryUsers {
    fn clear(&mut self) {
        self.clear_ids();
        self.clear_names();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for QueryUsers {
    fn eq(&self, other: &QueryUsers) -> bool {
        self.ids == other.ids &&
        self.names == other.names &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for QueryUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CryptSetup {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    client_nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    server_nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CryptSetup {}

impl CryptSetup {
    pub fn new() -> CryptSetup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CryptSetup {
        static mut instance: ::protobuf::lazy::Lazy<CryptSetup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CryptSetup,
        };
        unsafe {
            instance.get(|| {
                CryptSetup {
                    key: ::protobuf::SingularField::none(),
                    client_nonce: ::protobuf::SingularField::none(),
                    server_nonce: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_key<'a>(&'a self) -> &'a [u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes client_nonce = 2;

    pub fn clear_client_nonce(&mut self) {
        self.client_nonce.clear();
    }

    pub fn has_client_nonce(&self) -> bool {
        self.client_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_nonce<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.client_nonce.is_none() {
            self.client_nonce.set_default();
        };
        self.client_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.client_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_client_nonce<'a>(&'a self) -> &'a [u8] {
        match self.client_nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes server_nonce = 3;

    pub fn clear_server_nonce(&mut self) {
        self.server_nonce.clear();
    }

    pub fn has_server_nonce(&self) -> bool {
        self.server_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.server_nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_nonce<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.server_nonce.is_none() {
            self.server_nonce.set_default();
        };
        self.server_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.server_nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_server_nonce<'a>(&'a self) -> &'a [u8] {
        match self.server_nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CryptSetup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.client_nonce));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.server_nonce));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in self.client_nonce.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in self.server_nonce.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            try!(os.write_bytes(1, &v));
        };
        if let Some(v) = self.client_nonce.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        if let Some(v) = self.server_nonce.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CryptSetup>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CryptSetup {
    fn new() -> CryptSetup {
        CryptSetup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CryptSetup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "key",
                    CryptSetup::has_key,
                    CryptSetup::get_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "client_nonce",
                    CryptSetup::has_client_nonce,
                    CryptSetup::get_client_nonce,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "server_nonce",
                    CryptSetup::has_server_nonce,
                    CryptSetup::get_server_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CryptSetup>(
                    "CryptSetup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CryptSetup {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_client_nonce();
        self.clear_server_nonce();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CryptSetup {
    fn eq(&self, other: &CryptSetup) -> bool {
        self.key == other.key &&
        self.client_nonce == other.client_nonce &&
        self.server_nonce == other.server_nonce &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CryptSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContextActionModify {
    // message fields
    action: ::protobuf::SingularField<::std::string::String>,
    text: ::protobuf::SingularField<::std::string::String>,
    context: ::std::option::Option<u32>,
    operation: ::std::option::Option<ContextActionModify_Operation>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContextActionModify {}

impl ContextActionModify {
    pub fn new() -> ContextActionModify {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContextActionModify {
        static mut instance: ::protobuf::lazy::Lazy<ContextActionModify> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContextActionModify,
        };
        unsafe {
            instance.get(|| {
                ContextActionModify {
                    action: ::protobuf::SingularField::none(),
                    text: ::protobuf::SingularField::none(),
                    context: ::std::option::Option::None,
                    operation: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string action = 1;

    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.action.is_none() {
            self.action.set_default();
        };
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_action<'a>(&'a self) -> &'a str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string text = 2;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a str {
        match self.text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 context = 3;

    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: u32) {
        self.context = ::std::option::Option::Some(v);
    }

    pub fn get_context<'a>(&self) -> u32 {
        self.context.unwrap_or(0)
    }

    // optional .MumbleProto.ContextActionModify.Operation operation = 4;

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ContextActionModify_Operation) {
        self.operation = ::std::option::Option::Some(v);
    }

    pub fn get_operation<'a>(&self) -> ContextActionModify_Operation {
        self.operation.unwrap_or(ContextActionModify_Operation::Add)
    }
}

impl ::protobuf::Message for ContextActionModify {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.text));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.context = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.operation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.action.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.text.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.context.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.operation.iter() {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.text.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.context {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.operation {
            try!(os.write_enum(4, v.value()));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContextActionModify>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContextActionModify {
    fn new() -> ContextActionModify {
        ContextActionModify::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContextActionModify>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "action",
                    ContextActionModify::has_action,
                    ContextActionModify::get_action,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "text",
                    ContextActionModify::has_text,
                    ContextActionModify::get_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "context",
                    ContextActionModify::has_context,
                    ContextActionModify::get_context,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "operation",
                    ContextActionModify::has_operation,
                    ContextActionModify::get_operation,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContextActionModify>(
                    "ContextActionModify",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContextActionModify {
    fn clear(&mut self) {
        self.clear_action();
        self.clear_text();
        self.clear_context();
        self.clear_operation();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContextActionModify {
    fn eq(&self, other: &ContextActionModify) -> bool {
        self.action == other.action &&
        self.text == other.text &&
        self.context == other.context &&
        self.operation == other.operation &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContextActionModify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContextActionModify_Context {
    Server = 1,
    Channel = 2,
    User = 4,
}

impl ::protobuf::ProtobufEnum for ContextActionModify_Context {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContextActionModify_Context> {
        match value {
            1 => ::std::option::Option::Some(ContextActionModify_Context::Server),
            2 => ::std::option::Option::Some(ContextActionModify_Context::Channel),
            4 => ::std::option::Option::Some(ContextActionModify_Context::User),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContextActionModify_Context] = &[
            ContextActionModify_Context::Server,
            ContextActionModify_Context::Channel,
            ContextActionModify_Context::User,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ContextActionModify_Context>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContextActionModify_Context", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContextActionModify_Context {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContextActionModify_Operation {
    Add = 0,
    Remove = 1,
}

impl ::protobuf::ProtobufEnum for ContextActionModify_Operation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContextActionModify_Operation> {
        match value {
            0 => ::std::option::Option::Some(ContextActionModify_Operation::Add),
            1 => ::std::option::Option::Some(ContextActionModify_Operation::Remove),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContextActionModify_Operation] = &[
            ContextActionModify_Operation::Add,
            ContextActionModify_Operation::Remove,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ContextActionModify_Operation>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContextActionModify_Operation", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContextActionModify_Operation {
}

#[derive(Clone,Default)]
pub struct ContextAction {
    // message fields
    session: ::std::option::Option<u32>,
    channel_id: ::std::option::Option<u32>,
    action: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContextAction {}

impl ContextAction {
    pub fn new() -> ContextAction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContextAction {
        static mut instance: ::protobuf::lazy::Lazy<ContextAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContextAction,
        };
        unsafe {
            instance.get(|| {
                ContextAction {
                    session: ::std::option::Option::None,
                    channel_id: ::std::option::Option::None,
                    action: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 session = 1;

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    pub fn get_session<'a>(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    // optional uint32 channel_id = 2;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // required string action = 3;

    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.action.is_none() {
            self.action.set_default();
        };
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_action<'a>(&'a self) -> &'a str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContextAction {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.action.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.action.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContextAction>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContextAction {
    fn new() -> ContextAction {
        ContextAction::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContextAction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "session",
                    ContextAction::has_session,
                    ContextAction::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    ContextAction::has_channel_id,
                    ContextAction::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "action",
                    ContextAction::has_action,
                    ContextAction::get_action,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContextAction>(
                    "ContextAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContextAction {
    fn clear(&mut self) {
        self.clear_session();
        self.clear_channel_id();
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContextAction {
    fn eq(&self, other: &ContextAction) -> bool {
        self.session == other.session &&
        self.channel_id == other.channel_id &&
        self.action == other.action &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContextAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UserList {
    // message fields
    users: ::protobuf::RepeatedField<UserList_User>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UserList {}

impl UserList {
    pub fn new() -> UserList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UserList {
        static mut instance: ::protobuf::lazy::Lazy<UserList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserList,
        };
        unsafe {
            instance.get(|| {
                UserList {
                    users: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .MumbleProto.UserList.User users = 1;

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<UserList_User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<UserList_User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<UserList_User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }

    pub fn get_users<'a>(&'a self) -> &'a [UserList_User] {
        &self.users
    }
}

impl ::protobuf::Message for UserList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.users.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.users.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UserList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UserList {
    fn new() -> UserList {
        UserList::new()
    }

    fn descriptor_static(_: ::std::option::Option<UserList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "users",
                    UserList::get_users,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserList>(
                    "UserList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UserList {
    fn clear(&mut self) {
        self.clear_users();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UserList {
    fn eq(&self, other: &UserList) -> bool {
        self.users == other.users &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UserList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UserList_User {
    // message fields
    user_id: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    last_seen: ::protobuf::SingularField<::std::string::String>,
    last_channel: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UserList_User {}

impl UserList_User {
    pub fn new() -> UserList_User {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UserList_User {
        static mut instance: ::protobuf::lazy::Lazy<UserList_User> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserList_User,
        };
        unsafe {
            instance.get(|| {
                UserList_User {
                    user_id: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    last_seen: ::protobuf::SingularField::none(),
                    last_channel: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: u32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    pub fn get_user_id<'a>(&self) -> u32 {
        self.user_id.unwrap_or(0)
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string last_seen = 3;

    pub fn clear_last_seen(&mut self) {
        self.last_seen.clear();
    }

    pub fn has_last_seen(&self) -> bool {
        self.last_seen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen(&mut self, v: ::std::string::String) {
        self.last_seen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_seen<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.last_seen.is_none() {
            self.last_seen.set_default();
        };
        self.last_seen.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_seen(&mut self) -> ::std::string::String {
        self.last_seen.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_last_seen<'a>(&'a self) -> &'a str {
        match self.last_seen.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 last_channel = 4;

    pub fn clear_last_channel(&mut self) {
        self.last_channel = ::std::option::Option::None;
    }

    pub fn has_last_channel(&self) -> bool {
        self.last_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_channel(&mut self, v: u32) {
        self.last_channel = ::std::option::Option::Some(v);
    }

    pub fn get_last_channel<'a>(&self) -> u32 {
        self.last_channel.unwrap_or(0)
    }
}

impl ::protobuf::Message for UserList_User {
    fn is_initialized(&self) -> bool {
        if self.user_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.user_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_seen));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_channel = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.user_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.last_seen.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.last_channel.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.last_seen.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.last_channel {
            try!(os.write_uint32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UserList_User>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UserList_User {
    fn new() -> UserList_User {
        UserList_User::new()
    }

    fn descriptor_static(_: ::std::option::Option<UserList_User>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "user_id",
                    UserList_User::has_user_id,
                    UserList_User::get_user_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    UserList_User::has_name,
                    UserList_User::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "last_seen",
                    UserList_User::has_last_seen,
                    UserList_User::get_last_seen,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_channel",
                    UserList_User::has_last_channel,
                    UserList_User::get_last_channel,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserList_User>(
                    "UserList_User",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UserList_User {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_name();
        self.clear_last_seen();
        self.clear_last_channel();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UserList_User {
    fn eq(&self, other: &UserList_User) -> bool {
        self.user_id == other.user_id &&
        self.name == other.name &&
        self.last_seen == other.last_seen &&
        self.last_channel == other.last_channel &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UserList_User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct VoiceTarget {
    // message fields
    id: ::std::option::Option<u32>,
    targets: ::protobuf::RepeatedField<VoiceTarget_Target>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VoiceTarget {}

impl VoiceTarget {
    pub fn new() -> VoiceTarget {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VoiceTarget {
        static mut instance: ::protobuf::lazy::Lazy<VoiceTarget> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VoiceTarget,
        };
        unsafe {
            instance.get(|| {
                VoiceTarget {
                    id: ::std::option::Option::None,
                    targets: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    pub fn get_id<'a>(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    // repeated .MumbleProto.VoiceTarget.Target targets = 2;

    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<VoiceTarget_Target>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<VoiceTarget_Target> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<VoiceTarget_Target> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }

    pub fn get_targets<'a>(&'a self) -> &'a [VoiceTarget_Target] {
        &self.targets
    }
}

impl ::protobuf::Message for VoiceTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.targets.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            try!(os.write_uint32(1, v));
        };
        for v in self.targets.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<VoiceTarget>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VoiceTarget {
    fn new() -> VoiceTarget {
        VoiceTarget::new()
    }

    fn descriptor_static(_: ::std::option::Option<VoiceTarget>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "id",
                    VoiceTarget::has_id,
                    VoiceTarget::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "targets",
                    VoiceTarget::get_targets,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoiceTarget>(
                    "VoiceTarget",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VoiceTarget {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_targets();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for VoiceTarget {
    fn eq(&self, other: &VoiceTarget) -> bool {
        self.id == other.id &&
        self.targets == other.targets &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for VoiceTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct VoiceTarget_Target {
    // message fields
    session: ::std::vec::Vec<u32>,
    channel_id: ::std::option::Option<u32>,
    group: ::protobuf::SingularField<::std::string::String>,
    links: ::std::option::Option<bool>,
    children: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VoiceTarget_Target {}

impl VoiceTarget_Target {
    pub fn new() -> VoiceTarget_Target {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VoiceTarget_Target {
        static mut instance: ::protobuf::lazy::Lazy<VoiceTarget_Target> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VoiceTarget_Target,
        };
        unsafe {
            instance.get(|| {
                VoiceTarget_Target {
                    session: ::std::vec::Vec::new(),
                    channel_id: ::std::option::Option::None,
                    group: ::protobuf::SingularField::none(),
                    links: ::std::option::Option::None,
                    children: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 session = 1;

    pub fn clear_session(&mut self) {
        self.session.clear();
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::std::vec::Vec<u32>) {
        self.session = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.session
    }

    // Take field
    pub fn take_session(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session, ::std::vec::Vec::new())
    }

    pub fn get_session<'a>(&'a self) -> &'a [u32] {
        &self.session
    }

    // optional uint32 channel_id = 2;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // optional string group = 3;

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        };
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_group<'a>(&'a self) -> &'a str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool links = 4;

    pub fn clear_links(&mut self) {
        self.links = ::std::option::Option::None;
    }

    pub fn has_links(&self) -> bool {
        self.links.is_some()
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: bool) {
        self.links = ::std::option::Option::Some(v);
    }

    pub fn get_links<'a>(&self) -> bool {
        self.links.unwrap_or(false)
    }

    // optional bool children = 5;

    pub fn clear_children(&mut self) {
        self.children = ::std::option::Option::None;
    }

    pub fn has_children(&self) -> bool {
        self.children.is_some()
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: bool) {
        self.children = ::std::option::Option::Some(v);
    }

    pub fn get_children<'a>(&self) -> bool {
        self.children.unwrap_or(false)
    }
}

impl ::protobuf::Message for VoiceTarget_Target {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.links = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.children = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.group.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.links.is_some() {
            my_size += 2;
        };
        if self.children.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.session.iter() {
            try!(os.write_uint32(1, *v));
        };
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.group.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.links {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.children {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<VoiceTarget_Target>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VoiceTarget_Target {
    fn new() -> VoiceTarget_Target {
        VoiceTarget_Target::new()
    }

    fn descriptor_static(_: ::std::option::Option<VoiceTarget_Target>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "session",
                    VoiceTarget_Target::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    VoiceTarget_Target::has_channel_id,
                    VoiceTarget_Target::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "group",
                    VoiceTarget_Target::has_group,
                    VoiceTarget_Target::get_group,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "links",
                    VoiceTarget_Target::has_links,
                    VoiceTarget_Target::get_links,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "children",
                    VoiceTarget_Target::has_children,
                    VoiceTarget_Target::get_children,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VoiceTarget_Target>(
                    "VoiceTarget_Target",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VoiceTarget_Target {
    fn clear(&mut self) {
        self.clear_session();
        self.clear_channel_id();
        self.clear_group();
        self.clear_links();
        self.clear_children();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for VoiceTarget_Target {
    fn eq(&self, other: &VoiceTarget_Target) -> bool {
        self.session == other.session &&
        self.channel_id == other.channel_id &&
        self.group == other.group &&
        self.links == other.links &&
        self.children == other.children &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for VoiceTarget_Target {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PermissionQuery {
    // message fields
    channel_id: ::std::option::Option<u32>,
    permissions: ::std::option::Option<u32>,
    flush: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PermissionQuery {}

impl PermissionQuery {
    pub fn new() -> PermissionQuery {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PermissionQuery {
        static mut instance: ::protobuf::lazy::Lazy<PermissionQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PermissionQuery,
        };
        unsafe {
            instance.get(|| {
                PermissionQuery {
                    channel_id: ::std::option::Option::None,
                    permissions: ::std::option::Option::None,
                    flush: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    pub fn get_channel_id<'a>(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    // optional uint32 permissions = 2;

    pub fn clear_permissions(&mut self) {
        self.permissions = ::std::option::Option::None;
    }

    pub fn has_permissions(&self) -> bool {
        self.permissions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: u32) {
        self.permissions = ::std::option::Option::Some(v);
    }

    pub fn get_permissions<'a>(&self) -> u32 {
        self.permissions.unwrap_or(0)
    }

    // optional bool flush = 3;

    pub fn clear_flush(&mut self) {
        self.flush = ::std::option::Option::None;
    }

    pub fn has_flush(&self) -> bool {
        self.flush.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flush(&mut self, v: bool) {
        self.flush = ::std::option::Option::Some(v);
    }

    pub fn get_flush<'a>(&self) -> bool {
        self.flush.unwrap_or(false)
    }
}

impl ::protobuf::Message for PermissionQuery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.channel_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.permissions = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.flush = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.channel_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.permissions.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.flush.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.channel_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.permissions {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.flush {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PermissionQuery>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PermissionQuery {
    fn new() -> PermissionQuery {
        PermissionQuery::new()
    }

    fn descriptor_static(_: ::std::option::Option<PermissionQuery>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "channel_id",
                    PermissionQuery::has_channel_id,
                    PermissionQuery::get_channel_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "permissions",
                    PermissionQuery::has_permissions,
                    PermissionQuery::get_permissions,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "flush",
                    PermissionQuery::has_flush,
                    PermissionQuery::get_flush,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PermissionQuery>(
                    "PermissionQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PermissionQuery {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_permissions();
        self.clear_flush();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PermissionQuery {
    fn eq(&self, other: &PermissionQuery) -> bool {
        self.channel_id == other.channel_id &&
        self.permissions == other.permissions &&
        self.flush == other.flush &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PermissionQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CodecVersion {
    // message fields
    alpha: ::std::option::Option<i32>,
    beta: ::std::option::Option<i32>,
    prefer_alpha: ::std::option::Option<bool>,
    opus: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CodecVersion {}

impl CodecVersion {
    pub fn new() -> CodecVersion {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CodecVersion {
        static mut instance: ::protobuf::lazy::Lazy<CodecVersion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CodecVersion,
        };
        unsafe {
            instance.get(|| {
                CodecVersion {
                    alpha: ::std::option::Option::None,
                    beta: ::std::option::Option::None,
                    prefer_alpha: ::std::option::Option::None,
                    opus: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int32 alpha = 1;

    pub fn clear_alpha(&mut self) {
        self.alpha = ::std::option::Option::None;
    }

    pub fn has_alpha(&self) -> bool {
        self.alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha(&mut self, v: i32) {
        self.alpha = ::std::option::Option::Some(v);
    }

    pub fn get_alpha<'a>(&self) -> i32 {
        self.alpha.unwrap_or(0)
    }

    // required int32 beta = 2;

    pub fn clear_beta(&mut self) {
        self.beta = ::std::option::Option::None;
    }

    pub fn has_beta(&self) -> bool {
        self.beta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta(&mut self, v: i32) {
        self.beta = ::std::option::Option::Some(v);
    }

    pub fn get_beta<'a>(&self) -> i32 {
        self.beta.unwrap_or(0)
    }

    // required bool prefer_alpha = 3;

    pub fn clear_prefer_alpha(&mut self) {
        self.prefer_alpha = ::std::option::Option::None;
    }

    pub fn has_prefer_alpha(&self) -> bool {
        self.prefer_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefer_alpha(&mut self, v: bool) {
        self.prefer_alpha = ::std::option::Option::Some(v);
    }

    pub fn get_prefer_alpha<'a>(&self) -> bool {
        self.prefer_alpha.unwrap_or(true)
    }

    // optional bool opus = 4;

    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }

    pub fn get_opus<'a>(&self) -> bool {
        self.opus.unwrap_or(false)
    }
}

impl ::protobuf::Message for CodecVersion {
    fn is_initialized(&self) -> bool {
        if self.alpha.is_none() {
            return false;
        };
        if self.beta.is_none() {
            return false;
        };
        if self.prefer_alpha.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.alpha = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.beta = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.prefer_alpha = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.opus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.alpha.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.beta.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.prefer_alpha.is_some() {
            my_size += 2;
        };
        if self.opus.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.alpha {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.beta {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.prefer_alpha {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.opus {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CodecVersion>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CodecVersion {
    fn new() -> CodecVersion {
        CodecVersion::new()
    }

    fn descriptor_static(_: ::std::option::Option<CodecVersion>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "alpha",
                    CodecVersion::has_alpha,
                    CodecVersion::get_alpha,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "beta",
                    CodecVersion::has_beta,
                    CodecVersion::get_beta,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "prefer_alpha",
                    CodecVersion::has_prefer_alpha,
                    CodecVersion::get_prefer_alpha,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "opus",
                    CodecVersion::has_opus,
                    CodecVersion::get_opus,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CodecVersion>(
                    "CodecVersion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CodecVersion {
    fn clear(&mut self) {
        self.clear_alpha();
        self.clear_beta();
        self.clear_prefer_alpha();
        self.clear_opus();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CodecVersion {
    fn eq(&self, other: &CodecVersion) -> bool {
        self.alpha == other.alpha &&
        self.beta == other.beta &&
        self.prefer_alpha == other.prefer_alpha &&
        self.opus == other.opus &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CodecVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UserStats {
    // message fields
    session: ::std::option::Option<u32>,
    stats_only: ::std::option::Option<bool>,
    certificates: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    from_client: ::protobuf::SingularPtrField<UserStats_Stats>,
    from_server: ::protobuf::SingularPtrField<UserStats_Stats>,
    udp_packets: ::std::option::Option<u32>,
    tcp_packets: ::std::option::Option<u32>,
    udp_ping_avg: ::std::option::Option<f32>,
    udp_ping_var: ::std::option::Option<f32>,
    tcp_ping_avg: ::std::option::Option<f32>,
    tcp_ping_var: ::std::option::Option<f32>,
    version: ::protobuf::SingularPtrField<Version>,
    celt_versions: ::std::vec::Vec<i32>,
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bandwidth: ::std::option::Option<u32>,
    onlinesecs: ::std::option::Option<u32>,
    idlesecs: ::std::option::Option<u32>,
    strong_certificate: ::std::option::Option<bool>,
    opus: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UserStats {}

impl UserStats {
    pub fn new() -> UserStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UserStats {
        static mut instance: ::protobuf::lazy::Lazy<UserStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserStats,
        };
        unsafe {
            instance.get(|| {
                UserStats {
                    session: ::std::option::Option::None,
                    stats_only: ::std::option::Option::None,
                    certificates: ::protobuf::RepeatedField::new(),
                    from_client: ::protobuf::SingularPtrField::none(),
                    from_server: ::protobuf::SingularPtrField::none(),
                    udp_packets: ::std::option::Option::None,
                    tcp_packets: ::std::option::Option::None,
                    udp_ping_avg: ::std::option::Option::None,
                    udp_ping_var: ::std::option::Option::None,
                    tcp_ping_avg: ::std::option::Option::None,
                    tcp_ping_var: ::std::option::Option::None,
                    version: ::protobuf::SingularPtrField::none(),
                    celt_versions: ::std::vec::Vec::new(),
                    address: ::protobuf::SingularField::none(),
                    bandwidth: ::std::option::Option::None,
                    onlinesecs: ::std::option::Option::None,
                    idlesecs: ::std::option::Option::None,
                    strong_certificate: ::std::option::Option::None,
                    opus: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 session = 1;

    pub fn clear_session(&mut self) {
        self.session = ::std::option::Option::None;
    }

    pub fn has_session(&self) -> bool {
        self.session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: u32) {
        self.session = ::std::option::Option::Some(v);
    }

    pub fn get_session<'a>(&self) -> u32 {
        self.session.unwrap_or(0)
    }

    // optional bool stats_only = 2;

    pub fn clear_stats_only(&mut self) {
        self.stats_only = ::std::option::Option::None;
    }

    pub fn has_stats_only(&self) -> bool {
        self.stats_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_only(&mut self, v: bool) {
        self.stats_only = ::std::option::Option::Some(v);
    }

    pub fn get_stats_only<'a>(&self) -> bool {
        self.stats_only.unwrap_or(false)
    }

    // repeated bytes certificates = 3;

    pub fn clear_certificates(&mut self) {
        self.certificates.clear();
    }

    // Param is passed by value, moved
    pub fn set_certificates(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.certificates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_certificates<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.certificates
    }

    // Take field
    pub fn take_certificates(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.certificates, ::protobuf::RepeatedField::new())
    }

    pub fn get_certificates<'a>(&'a self) -> &'a [::std::vec::Vec<u8>] {
        &self.certificates
    }

    // optional .MumbleProto.UserStats.Stats from_client = 4;

    pub fn clear_from_client(&mut self) {
        self.from_client.clear();
    }

    pub fn has_from_client(&self) -> bool {
        self.from_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_client(&mut self, v: UserStats_Stats) {
        self.from_client = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_client<'a>(&'a mut self) -> &'a mut UserStats_Stats {
        if self.from_client.is_none() {
            self.from_client.set_default();
        };
        self.from_client.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_client(&mut self) -> UserStats_Stats {
        self.from_client.take().unwrap_or_else(|| UserStats_Stats::new())
    }

    pub fn get_from_client<'a>(&'a self) -> &'a UserStats_Stats {
        self.from_client.as_ref().unwrap_or_else(|| UserStats_Stats::default_instance())
    }

    // optional .MumbleProto.UserStats.Stats from_server = 5;

    pub fn clear_from_server(&mut self) {
        self.from_server.clear();
    }

    pub fn has_from_server(&self) -> bool {
        self.from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_server(&mut self, v: UserStats_Stats) {
        self.from_server = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_server<'a>(&'a mut self) -> &'a mut UserStats_Stats {
        if self.from_server.is_none() {
            self.from_server.set_default();
        };
        self.from_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_server(&mut self) -> UserStats_Stats {
        self.from_server.take().unwrap_or_else(|| UserStats_Stats::new())
    }

    pub fn get_from_server<'a>(&'a self) -> &'a UserStats_Stats {
        self.from_server.as_ref().unwrap_or_else(|| UserStats_Stats::default_instance())
    }

    // optional uint32 udp_packets = 6;

    pub fn clear_udp_packets(&mut self) {
        self.udp_packets = ::std::option::Option::None;
    }

    pub fn has_udp_packets(&self) -> bool {
        self.udp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_packets(&mut self, v: u32) {
        self.udp_packets = ::std::option::Option::Some(v);
    }

    pub fn get_udp_packets<'a>(&self) -> u32 {
        self.udp_packets.unwrap_or(0)
    }

    // optional uint32 tcp_packets = 7;

    pub fn clear_tcp_packets(&mut self) {
        self.tcp_packets = ::std::option::Option::None;
    }

    pub fn has_tcp_packets(&self) -> bool {
        self.tcp_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_packets(&mut self, v: u32) {
        self.tcp_packets = ::std::option::Option::Some(v);
    }

    pub fn get_tcp_packets<'a>(&self) -> u32 {
        self.tcp_packets.unwrap_or(0)
    }

    // optional float udp_ping_avg = 8;

    pub fn clear_udp_ping_avg(&mut self) {
        self.udp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_udp_ping_avg(&self) -> bool {
        self.udp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_avg(&mut self, v: f32) {
        self.udp_ping_avg = ::std::option::Option::Some(v);
    }

    pub fn get_udp_ping_avg<'a>(&self) -> f32 {
        self.udp_ping_avg.unwrap_or(0.)
    }

    // optional float udp_ping_var = 9;

    pub fn clear_udp_ping_var(&mut self) {
        self.udp_ping_var = ::std::option::Option::None;
    }

    pub fn has_udp_ping_var(&self) -> bool {
        self.udp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_ping_var(&mut self, v: f32) {
        self.udp_ping_var = ::std::option::Option::Some(v);
    }

    pub fn get_udp_ping_var<'a>(&self) -> f32 {
        self.udp_ping_var.unwrap_or(0.)
    }

    // optional float tcp_ping_avg = 10;

    pub fn clear_tcp_ping_avg(&mut self) {
        self.tcp_ping_avg = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_avg(&self) -> bool {
        self.tcp_ping_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_avg(&mut self, v: f32) {
        self.tcp_ping_avg = ::std::option::Option::Some(v);
    }

    pub fn get_tcp_ping_avg<'a>(&self) -> f32 {
        self.tcp_ping_avg.unwrap_or(0.)
    }

    // optional float tcp_ping_var = 11;

    pub fn clear_tcp_ping_var(&mut self) {
        self.tcp_ping_var = ::std::option::Option::None;
    }

    pub fn has_tcp_ping_var(&self) -> bool {
        self.tcp_ping_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_ping_var(&mut self, v: f32) {
        self.tcp_ping_var = ::std::option::Option::Some(v);
    }

    pub fn get_tcp_ping_var<'a>(&self) -> f32 {
        self.tcp_ping_var.unwrap_or(0.)
    }

    // optional .MumbleProto.Version version = 12;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: Version) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version<'a>(&'a mut self) -> &'a mut Version {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> Version {
        self.version.take().unwrap_or_else(|| Version::new())
    }

    pub fn get_version<'a>(&'a self) -> &'a Version {
        self.version.as_ref().unwrap_or_else(|| Version::default_instance())
    }

    // repeated int32 celt_versions = 13;

    pub fn clear_celt_versions(&mut self) {
        self.celt_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_celt_versions(&mut self, v: ::std::vec::Vec<i32>) {
        self.celt_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_celt_versions<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<i32> {
        &mut self.celt_versions
    }

    // Take field
    pub fn take_celt_versions(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.celt_versions, ::std::vec::Vec::new())
    }

    pub fn get_celt_versions<'a>(&'a self) -> &'a [i32] {
        &self.celt_versions
    }

    // optional bytes address = 14;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        };
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_address<'a>(&'a self) -> &'a [u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 bandwidth = 15;

    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: u32) {
        self.bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_bandwidth<'a>(&self) -> u32 {
        self.bandwidth.unwrap_or(0)
    }

    // optional uint32 onlinesecs = 16;

    pub fn clear_onlinesecs(&mut self) {
        self.onlinesecs = ::std::option::Option::None;
    }

    pub fn has_onlinesecs(&self) -> bool {
        self.onlinesecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onlinesecs(&mut self, v: u32) {
        self.onlinesecs = ::std::option::Option::Some(v);
    }

    pub fn get_onlinesecs<'a>(&self) -> u32 {
        self.onlinesecs.unwrap_or(0)
    }

    // optional uint32 idlesecs = 17;

    pub fn clear_idlesecs(&mut self) {
        self.idlesecs = ::std::option::Option::None;
    }

    pub fn has_idlesecs(&self) -> bool {
        self.idlesecs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idlesecs(&mut self, v: u32) {
        self.idlesecs = ::std::option::Option::Some(v);
    }

    pub fn get_idlesecs<'a>(&self) -> u32 {
        self.idlesecs.unwrap_or(0)
    }

    // optional bool strong_certificate = 18;

    pub fn clear_strong_certificate(&mut self) {
        self.strong_certificate = ::std::option::Option::None;
    }

    pub fn has_strong_certificate(&self) -> bool {
        self.strong_certificate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strong_certificate(&mut self, v: bool) {
        self.strong_certificate = ::std::option::Option::Some(v);
    }

    pub fn get_strong_certificate<'a>(&self) -> bool {
        self.strong_certificate.unwrap_or(false)
    }

    // optional bool opus = 19;

    pub fn clear_opus(&mut self) {
        self.opus = ::std::option::Option::None;
    }

    pub fn has_opus(&self) -> bool {
        self.opus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opus(&mut self, v: bool) {
        self.opus = ::std::option::Option::Some(v);
    }

    pub fn get_opus<'a>(&self) -> bool {
        self.opus.unwrap_or(false)
    }
}

impl ::protobuf::Message for UserStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.session = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.stats_only = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.certificates));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_client));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from_server));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.udp_packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.tcp_packets = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.udp_ping_avg = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.udp_ping_var = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.tcp_ping_avg = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.tcp_ping_var = ::std::option::Option::Some(tmp);
                },
                12 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version));
                },
                13 => {
                    try!(::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.celt_versions));
                },
                14 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.onlinesecs = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.idlesecs = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.strong_certificate = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.opus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.stats_only.is_some() {
            my_size += 2;
        };
        for value in self.certificates.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.from_client.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.from_server.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.udp_packets.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tcp_packets.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.udp_ping_avg.is_some() {
            my_size += 5;
        };
        if self.udp_ping_var.is_some() {
            my_size += 5;
        };
        if self.tcp_ping_avg.is_some() {
            my_size += 5;
        };
        if self.tcp_ping_var.is_some() {
            my_size += 5;
        };
        for value in self.version.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.celt_versions.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.address.iter() {
            my_size += ::protobuf::rt::bytes_size(14, &value);
        };
        for value in self.bandwidth.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.onlinesecs.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.idlesecs.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.strong_certificate.is_some() {
            my_size += 3;
        };
        if self.opus.is_some() {
            my_size += 3;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.session {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.stats_only {
            try!(os.write_bool(2, v));
        };
        for v in self.certificates.iter() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.from_client.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.from_server.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.udp_packets {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.tcp_packets {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.udp_ping_avg {
            try!(os.write_float(8, v));
        };
        if let Some(v) = self.udp_ping_var {
            try!(os.write_float(9, v));
        };
        if let Some(v) = self.tcp_ping_avg {
            try!(os.write_float(10, v));
        };
        if let Some(v) = self.tcp_ping_var {
            try!(os.write_float(11, v));
        };
        if let Some(v) = self.version.as_ref() {
            try!(os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.celt_versions.iter() {
            try!(os.write_int32(13, *v));
        };
        if let Some(v) = self.address.as_ref() {
            try!(os.write_bytes(14, &v));
        };
        if let Some(v) = self.bandwidth {
            try!(os.write_uint32(15, v));
        };
        if let Some(v) = self.onlinesecs {
            try!(os.write_uint32(16, v));
        };
        if let Some(v) = self.idlesecs {
            try!(os.write_uint32(17, v));
        };
        if let Some(v) = self.strong_certificate {
            try!(os.write_bool(18, v));
        };
        if let Some(v) = self.opus {
            try!(os.write_bool(19, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UserStats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UserStats {
    fn new() -> UserStats {
        UserStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<UserStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "session",
                    UserStats::has_session,
                    UserStats::get_session,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "stats_only",
                    UserStats::has_stats_only,
                    UserStats::get_stats_only,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_bytes_accessor(
                    "certificates",
                    UserStats::get_certificates,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "from_client",
                    UserStats::has_from_client,
                    UserStats::get_from_client,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "from_server",
                    UserStats::has_from_server,
                    UserStats::get_from_server,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "udp_packets",
                    UserStats::has_udp_packets,
                    UserStats::get_udp_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "tcp_packets",
                    UserStats::has_tcp_packets,
                    UserStats::get_tcp_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "udp_ping_avg",
                    UserStats::has_udp_ping_avg,
                    UserStats::get_udp_ping_avg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "udp_ping_var",
                    UserStats::has_udp_ping_var,
                    UserStats::get_udp_ping_var,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "tcp_ping_avg",
                    UserStats::has_tcp_ping_avg,
                    UserStats::get_tcp_ping_avg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "tcp_ping_var",
                    UserStats::has_tcp_ping_var,
                    UserStats::get_tcp_ping_var,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "version",
                    UserStats::has_version,
                    UserStats::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_i32_accessor(
                    "celt_versions",
                    UserStats::get_celt_versions,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "address",
                    UserStats::has_address,
                    UserStats::get_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "bandwidth",
                    UserStats::has_bandwidth,
                    UserStats::get_bandwidth,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "onlinesecs",
                    UserStats::has_onlinesecs,
                    UserStats::get_onlinesecs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "idlesecs",
                    UserStats::has_idlesecs,
                    UserStats::get_idlesecs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "strong_certificate",
                    UserStats::has_strong_certificate,
                    UserStats::get_strong_certificate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "opus",
                    UserStats::has_opus,
                    UserStats::get_opus,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserStats>(
                    "UserStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UserStats {
    fn clear(&mut self) {
        self.clear_session();
        self.clear_stats_only();
        self.clear_certificates();
        self.clear_from_client();
        self.clear_from_server();
        self.clear_udp_packets();
        self.clear_tcp_packets();
        self.clear_udp_ping_avg();
        self.clear_udp_ping_var();
        self.clear_tcp_ping_avg();
        self.clear_tcp_ping_var();
        self.clear_version();
        self.clear_celt_versions();
        self.clear_address();
        self.clear_bandwidth();
        self.clear_onlinesecs();
        self.clear_idlesecs();
        self.clear_strong_certificate();
        self.clear_opus();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UserStats {
    fn eq(&self, other: &UserStats) -> bool {
        self.session == other.session &&
        self.stats_only == other.stats_only &&
        self.certificates == other.certificates &&
        self.from_client == other.from_client &&
        self.from_server == other.from_server &&
        self.udp_packets == other.udp_packets &&
        self.tcp_packets == other.tcp_packets &&
        self.udp_ping_avg == other.udp_ping_avg &&
        self.udp_ping_var == other.udp_ping_var &&
        self.tcp_ping_avg == other.tcp_ping_avg &&
        self.tcp_ping_var == other.tcp_ping_var &&
        self.version == other.version &&
        self.celt_versions == other.celt_versions &&
        self.address == other.address &&
        self.bandwidth == other.bandwidth &&
        self.onlinesecs == other.onlinesecs &&
        self.idlesecs == other.idlesecs &&
        self.strong_certificate == other.strong_certificate &&
        self.opus == other.opus &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UserStats_Stats {
    // message fields
    good: ::std::option::Option<u32>,
    late: ::std::option::Option<u32>,
    lost: ::std::option::Option<u32>,
    resync: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UserStats_Stats {}

impl UserStats_Stats {
    pub fn new() -> UserStats_Stats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UserStats_Stats {
        static mut instance: ::protobuf::lazy::Lazy<UserStats_Stats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserStats_Stats,
        };
        unsafe {
            instance.get(|| {
                UserStats_Stats {
                    good: ::std::option::Option::None,
                    late: ::std::option::Option::None,
                    lost: ::std::option::Option::None,
                    resync: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 good = 1;

    pub fn clear_good(&mut self) {
        self.good = ::std::option::Option::None;
    }

    pub fn has_good(&self) -> bool {
        self.good.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good(&mut self, v: u32) {
        self.good = ::std::option::Option::Some(v);
    }

    pub fn get_good<'a>(&self) -> u32 {
        self.good.unwrap_or(0)
    }

    // optional uint32 late = 2;

    pub fn clear_late(&mut self) {
        self.late = ::std::option::Option::None;
    }

    pub fn has_late(&self) -> bool {
        self.late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late(&mut self, v: u32) {
        self.late = ::std::option::Option::Some(v);
    }

    pub fn get_late<'a>(&self) -> u32 {
        self.late.unwrap_or(0)
    }

    // optional uint32 lost = 3;

    pub fn clear_lost(&mut self) {
        self.lost = ::std::option::Option::None;
    }

    pub fn has_lost(&self) -> bool {
        self.lost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lost(&mut self, v: u32) {
        self.lost = ::std::option::Option::Some(v);
    }

    pub fn get_lost<'a>(&self) -> u32 {
        self.lost.unwrap_or(0)
    }

    // optional uint32 resync = 4;

    pub fn clear_resync(&mut self) {
        self.resync = ::std::option::Option::None;
    }

    pub fn has_resync(&self) -> bool {
        self.resync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resync(&mut self, v: u32) {
        self.resync = ::std::option::Option::Some(v);
    }

    pub fn get_resync<'a>(&self) -> u32 {
        self.resync.unwrap_or(0)
    }
}

impl ::protobuf::Message for UserStats_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.good = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.late = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.lost = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.resync = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.good.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.late.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lost.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.resync.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.good {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.late {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.lost {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.resync {
            try!(os.write_uint32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UserStats_Stats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UserStats_Stats {
    fn new() -> UserStats_Stats {
        UserStats_Stats::new()
    }

    fn descriptor_static(_: ::std::option::Option<UserStats_Stats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "good",
                    UserStats_Stats::has_good,
                    UserStats_Stats::get_good,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "late",
                    UserStats_Stats::has_late,
                    UserStats_Stats::get_late,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "lost",
                    UserStats_Stats::has_lost,
                    UserStats_Stats::get_lost,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "resync",
                    UserStats_Stats::has_resync,
                    UserStats_Stats::get_resync,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserStats_Stats>(
                    "UserStats_Stats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UserStats_Stats {
    fn clear(&mut self) {
        self.clear_good();
        self.clear_late();
        self.clear_lost();
        self.clear_resync();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UserStats_Stats {
    fn eq(&self, other: &UserStats_Stats) -> bool {
        self.good == other.good &&
        self.late == other.late &&
        self.lost == other.lost &&
        self.resync == other.resync &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UserStats_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RequestBlob {
    // message fields
    session_texture: ::std::vec::Vec<u32>,
    session_comment: ::std::vec::Vec<u32>,
    channel_description: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RequestBlob {}

impl RequestBlob {
    pub fn new() -> RequestBlob {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RequestBlob {
        static mut instance: ::protobuf::lazy::Lazy<RequestBlob> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestBlob,
        };
        unsafe {
            instance.get(|| {
                RequestBlob {
                    session_texture: ::std::vec::Vec::new(),
                    session_comment: ::std::vec::Vec::new(),
                    channel_description: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 session_texture = 1;

    pub fn clear_session_texture(&mut self) {
        self.session_texture.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_texture(&mut self, v: ::std::vec::Vec<u32>) {
        self.session_texture = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_texture<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.session_texture
    }

    // Take field
    pub fn take_session_texture(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session_texture, ::std::vec::Vec::new())
    }

    pub fn get_session_texture<'a>(&'a self) -> &'a [u32] {
        &self.session_texture
    }

    // repeated uint32 session_comment = 2;

    pub fn clear_session_comment(&mut self) {
        self.session_comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_comment(&mut self, v: ::std::vec::Vec<u32>) {
        self.session_comment = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session_comment<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.session_comment
    }

    // Take field
    pub fn take_session_comment(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.session_comment, ::std::vec::Vec::new())
    }

    pub fn get_session_comment<'a>(&'a self) -> &'a [u32] {
        &self.session_comment
    }

    // repeated uint32 channel_description = 3;

    pub fn clear_channel_description(&mut self) {
        self.channel_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_description(&mut self, v: ::std::vec::Vec<u32>) {
        self.channel_description = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_description<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.channel_description
    }

    // Take field
    pub fn take_channel_description(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.channel_description, ::std::vec::Vec::new())
    }

    pub fn get_channel_description<'a>(&'a self) -> &'a [u32] {
        &self.channel_description
    }
}

impl ::protobuf::Message for RequestBlob {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session_texture));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.session_comment));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.channel_description));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.session_texture.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.session_comment.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.channel_description.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.session_texture.iter() {
            try!(os.write_uint32(1, *v));
        };
        for v in self.session_comment.iter() {
            try!(os.write_uint32(2, *v));
        };
        for v in self.channel_description.iter() {
            try!(os.write_uint32(3, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RequestBlob>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RequestBlob {
    fn new() -> RequestBlob {
        RequestBlob::new()
    }

    fn descriptor_static(_: ::std::option::Option<RequestBlob>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "session_texture",
                    RequestBlob::get_session_texture,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "session_comment",
                    RequestBlob::get_session_comment,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "channel_description",
                    RequestBlob::get_channel_description,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestBlob>(
                    "RequestBlob",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RequestBlob {
    fn clear(&mut self) {
        self.clear_session_texture();
        self.clear_session_comment();
        self.clear_channel_description();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RequestBlob {
    fn eq(&self, other: &RequestBlob) -> bool {
        self.session_texture == other.session_texture &&
        self.session_comment == other.session_comment &&
        self.channel_description == other.channel_description &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RequestBlob {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ServerConfig {
    // message fields
    max_bandwidth: ::std::option::Option<u32>,
    welcome_text: ::protobuf::SingularField<::std::string::String>,
    allow_html: ::std::option::Option<bool>,
    message_length: ::std::option::Option<u32>,
    image_message_length: ::std::option::Option<u32>,
    max_users: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServerConfig {}

impl ServerConfig {
    pub fn new() -> ServerConfig {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServerConfig {
        static mut instance: ::protobuf::lazy::Lazy<ServerConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerConfig,
        };
        unsafe {
            instance.get(|| {
                ServerConfig {
                    max_bandwidth: ::std::option::Option::None,
                    welcome_text: ::protobuf::SingularField::none(),
                    allow_html: ::std::option::Option::None,
                    message_length: ::std::option::Option::None,
                    image_message_length: ::std::option::Option::None,
                    max_users: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 max_bandwidth = 1;

    pub fn clear_max_bandwidth(&mut self) {
        self.max_bandwidth = ::std::option::Option::None;
    }

    pub fn has_max_bandwidth(&self) -> bool {
        self.max_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_bandwidth(&mut self, v: u32) {
        self.max_bandwidth = ::std::option::Option::Some(v);
    }

    pub fn get_max_bandwidth<'a>(&self) -> u32 {
        self.max_bandwidth.unwrap_or(0)
    }

    // optional string welcome_text = 2;

    pub fn clear_welcome_text(&mut self) {
        self.welcome_text.clear();
    }

    pub fn has_welcome_text(&self) -> bool {
        self.welcome_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome_text(&mut self, v: ::std::string::String) {
        self.welcome_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome_text<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.welcome_text.is_none() {
            self.welcome_text.set_default();
        };
        self.welcome_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome_text(&mut self) -> ::std::string::String {
        self.welcome_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_welcome_text<'a>(&'a self) -> &'a str {
        match self.welcome_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool allow_html = 3;

    pub fn clear_allow_html(&mut self) {
        self.allow_html = ::std::option::Option::None;
    }

    pub fn has_allow_html(&self) -> bool {
        self.allow_html.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_html(&mut self, v: bool) {
        self.allow_html = ::std::option::Option::Some(v);
    }

    pub fn get_allow_html<'a>(&self) -> bool {
        self.allow_html.unwrap_or(false)
    }

    // optional uint32 message_length = 4;

    pub fn clear_message_length(&mut self) {
        self.message_length = ::std::option::Option::None;
    }

    pub fn has_message_length(&self) -> bool {
        self.message_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_length(&mut self, v: u32) {
        self.message_length = ::std::option::Option::Some(v);
    }

    pub fn get_message_length<'a>(&self) -> u32 {
        self.message_length.unwrap_or(0)
    }

    // optional uint32 image_message_length = 5;

    pub fn clear_image_message_length(&mut self) {
        self.image_message_length = ::std::option::Option::None;
    }

    pub fn has_image_message_length(&self) -> bool {
        self.image_message_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_message_length(&mut self, v: u32) {
        self.image_message_length = ::std::option::Option::Some(v);
    }

    pub fn get_image_message_length<'a>(&self) -> u32 {
        self.image_message_length.unwrap_or(0)
    }

    // optional uint32 max_users = 6;

    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }

    pub fn get_max_users<'a>(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }
}

impl ::protobuf::Message for ServerConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.max_bandwidth = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.welcome_text));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.allow_html = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.message_length = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.image_message_length = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.max_users = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.max_bandwidth.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.welcome_text.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.allow_html.is_some() {
            my_size += 2;
        };
        for value in self.message_length.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.image_message_length.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.max_users.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_bandwidth {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.welcome_text.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.allow_html {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.message_length {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.image_message_length {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.max_users {
            try!(os.write_uint32(6, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ServerConfig>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServerConfig {
    fn new() -> ServerConfig {
        ServerConfig::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServerConfig>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "max_bandwidth",
                    ServerConfig::has_max_bandwidth,
                    ServerConfig::get_max_bandwidth,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "welcome_text",
                    ServerConfig::has_welcome_text,
                    ServerConfig::get_welcome_text,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "allow_html",
                    ServerConfig::has_allow_html,
                    ServerConfig::get_allow_html,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "message_length",
                    ServerConfig::has_message_length,
                    ServerConfig::get_message_length,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "image_message_length",
                    ServerConfig::has_image_message_length,
                    ServerConfig::get_image_message_length,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "max_users",
                    ServerConfig::has_max_users,
                    ServerConfig::get_max_users,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerConfig>(
                    "ServerConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServerConfig {
    fn clear(&mut self) {
        self.clear_max_bandwidth();
        self.clear_welcome_text();
        self.clear_allow_html();
        self.clear_message_length();
        self.clear_image_message_length();
        self.clear_max_users();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ServerConfig {
    fn eq(&self, other: &ServerConfig) -> bool {
        self.max_bandwidth == other.max_bandwidth &&
        self.welcome_text == other.welcome_text &&
        self.allow_html == other.allow_html &&
        self.message_length == other.message_length &&
        self.image_message_length == other.image_message_length &&
        self.max_users == other.max_users &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SuggestConfig {
    // message fields
    version: ::std::option::Option<u32>,
    positional: ::std::option::Option<bool>,
    push_to_talk: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SuggestConfig {}

impl SuggestConfig {
    pub fn new() -> SuggestConfig {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SuggestConfig {
        static mut instance: ::protobuf::lazy::Lazy<SuggestConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SuggestConfig,
        };
        unsafe {
            instance.get(|| {
                SuggestConfig {
                    version: ::std::option::Option::None,
                    positional: ::std::option::Option::None,
                    push_to_talk: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    pub fn get_version<'a>(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    // optional bool positional = 2;

    pub fn clear_positional(&mut self) {
        self.positional = ::std::option::Option::None;
    }

    pub fn has_positional(&self) -> bool {
        self.positional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positional(&mut self, v: bool) {
        self.positional = ::std::option::Option::Some(v);
    }

    pub fn get_positional<'a>(&self) -> bool {
        self.positional.unwrap_or(false)
    }

    // optional bool push_to_talk = 3;

    pub fn clear_push_to_talk(&mut self) {
        self.push_to_talk = ::std::option::Option::None;
    }

    pub fn has_push_to_talk(&self) -> bool {
        self.push_to_talk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_to_talk(&mut self, v: bool) {
        self.push_to_talk = ::std::option::Option::Some(v);
    }

    pub fn get_push_to_talk<'a>(&self) -> bool {
        self.push_to_talk.unwrap_or(false)
    }
}

impl ::protobuf::Message for SuggestConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.positional = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.push_to_talk = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.positional.is_some() {
            my_size += 2;
        };
        if self.push_to_talk.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.positional {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.push_to_talk {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SuggestConfig>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SuggestConfig {
    fn new() -> SuggestConfig {
        SuggestConfig::new()
    }

    fn descriptor_static(_: ::std::option::Option<SuggestConfig>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "version",
                    SuggestConfig::has_version,
                    SuggestConfig::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "positional",
                    SuggestConfig::has_positional,
                    SuggestConfig::get_positional,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "push_to_talk",
                    SuggestConfig::has_push_to_talk,
                    SuggestConfig::get_push_to_talk,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SuggestConfig>(
                    "SuggestConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SuggestConfig {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_positional();
        self.clear_push_to_talk();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SuggestConfig {
    fn eq(&self, other: &SuggestConfig) -> bool {
        self.version == other.version &&
        self.positional == other.positional &&
        self.push_to_talk == other.push_to_talk &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SuggestConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x0c, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b,
    0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x4b, 0x0a, 0x07, 0x56,
    0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x0f, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x72, 0x65, 0x6c, 0x65, 0x61,
    0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0a, 0x0a, 0x02, 0x6f, 0x73, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x6f, 0x73, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69,
    0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x22, 0x1b, 0x0a, 0x09, 0x55, 0x44, 0x50, 0x54,
    0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x0e, 0x0a, 0x06, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0c, 0x22, 0x6e, 0x0a, 0x0c, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
    0x69, 0x63, 0x61, 0x74, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77,
    0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x74, 0x6f, 0x6b,
    0x65, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x65, 0x6c,
    0x74, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x05,
    0x12, 0x13, 0x0a, 0x04, 0x6f, 0x70, 0x75, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05,
    0x66, 0x61, 0x6c, 0x73, 0x65, 0x22, 0xd5, 0x01, 0x0a, 0x04, 0x50, 0x69, 0x6e, 0x67, 0x12, 0x11,
    0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x0c, 0x0a, 0x04, 0x67, 0x6f, 0x6f, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x0c, 0x0a, 0x04, 0x6c, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a,
    0x04, 0x6c, 0x6f, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x72,
    0x65, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x75,
    0x64, 0x70, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x13, 0x0a, 0x0b, 0x74, 0x63, 0x70, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x75, 0x64, 0x70, 0x5f, 0x70, 0x69, 0x6e,
    0x67, 0x5f, 0x61, 0x76, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x12, 0x14, 0x0a, 0x0c, 0x75,
    0x64, 0x70, 0x5f, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x02, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x63, 0x70, 0x5f, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x76,
    0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x02, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x63, 0x70, 0x5f, 0x70,
    0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x72, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x02, 0x22, 0xf7, 0x01,
    0x0a, 0x06, 0x52, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x2c, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50,
    0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x52, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x2e, 0x52, 0x65, 0x6a, 0x65,
    0x63, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0xae, 0x01, 0x0a, 0x0a, 0x52, 0x65, 0x6a, 0x65, 0x63,
    0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x6f, 0x6e, 0x65, 0x10, 0x00, 0x12,
    0x10, 0x0a, 0x0c, 0x57, 0x72, 0x6f, 0x6e, 0x67, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x10,
    0x01, 0x12, 0x13, 0x0a, 0x0f, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x55, 0x73, 0x65, 0x72,
    0x6e, 0x61, 0x6d, 0x65, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x57, 0x72, 0x6f, 0x6e, 0x67, 0x55,
    0x73, 0x65, 0x72, 0x50, 0x57, 0x10, 0x03, 0x12, 0x11, 0x0a, 0x0d, 0x57, 0x72, 0x6f, 0x6e, 0x67,
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x50, 0x57, 0x10, 0x04, 0x12, 0x11, 0x0a, 0x0d, 0x55, 0x73,
    0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x55, 0x73, 0x65, 0x10, 0x05, 0x12, 0x0e, 0x0a,
    0x0a, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x46, 0x75, 0x6c, 0x6c, 0x10, 0x06, 0x12, 0x11, 0x0a,
    0x0d, 0x4e, 0x6f, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x10, 0x07,
    0x12, 0x15, 0x0a, 0x11, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f,
    0x72, 0x46, 0x61, 0x69, 0x6c, 0x10, 0x08, 0x22, 0x5f, 0x0a, 0x0a, 0x53, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x53, 0x79, 0x6e, 0x63, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x61,
    0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a,
    0x0c, 0x77, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x22, 0x23, 0x0a, 0x0d, 0x43, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x22, 0xe9, 0x01,
    0x0a, 0x0c, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x12,
    0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x0d, 0x0a, 0x05, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0d, 0x12,
    0x13, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x5f, 0x61, 0x64,
    0x64, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x6c, 0x69, 0x6e, 0x6b, 0x73,
    0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x18, 0x0a,
    0x09, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08,
    0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12, 0x13, 0x0a, 0x08, 0x70, 0x6f, 0x73, 0x69, 0x74,
    0x69, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x30, 0x12, 0x18, 0x0a, 0x10,
    0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x68, 0x61, 0x73, 0x68,
    0x18, 0x0a, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x11, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x75, 0x73,
    0x65, 0x72, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x49, 0x0a, 0x0a, 0x55, 0x73, 0x65,
    0x72, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x63, 0x74, 0x6f,
    0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x61, 0x73, 0x6f,
    0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0b, 0x0a, 0x03, 0x62, 0x61, 0x6e, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x08, 0x22, 0xec, 0x02, 0x0a, 0x09, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61,
    0x74, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x0f, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6d, 0x75, 0x74, 0x65, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x65, 0x61, 0x66, 0x18, 0x07, 0x20, 0x01, 0x28,
    0x08, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x75, 0x70, 0x70, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x11, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x66, 0x5f, 0x6d, 0x75, 0x74, 0x65,
    0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x12, 0x11, 0x0a, 0x09, 0x73, 0x65, 0x6c, 0x66, 0x5f, 0x64,
    0x65, 0x61, 0x66, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0f, 0x0a, 0x07, 0x74, 0x65, 0x78,
    0x74, 0x75, 0x72, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x16, 0x0a, 0x0e, 0x70, 0x6c,
    0x75, 0x67, 0x69, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x0c, 0x20, 0x01,
    0x28, 0x0c, 0x12, 0x17, 0x0a, 0x0f, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x5f, 0x69, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x63,
    0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04,
    0x68, 0x61, 0x73, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x6f,
    0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x14, 0x0a, 0x0c, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x68, 0x61, 0x73, 0x68,
    0x18, 0x11, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x18, 0x0a, 0x10, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69,
    0x74, 0x79, 0x5f, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x18, 0x12, 0x20, 0x01, 0x28, 0x08,
    0x12, 0x11, 0x0a, 0x09, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x13, 0x20,
    0x01, 0x28, 0x08, 0x22, 0xc4, 0x01, 0x0a, 0x07, 0x42, 0x61, 0x6e, 0x4c, 0x69, 0x73, 0x74, 0x12,
    0x2b, 0x0a, 0x04, 0x62, 0x61, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e,
    0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x42, 0x61, 0x6e, 0x4c,
    0x69, 0x73, 0x74, 0x2e, 0x42, 0x61, 0x6e, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x14, 0x0a, 0x05,
    0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c,
    0x73, 0x65, 0x1a, 0x76, 0x0a, 0x08, 0x42, 0x61, 0x6e, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x0f,
    0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0c, 0x12,
    0x0c, 0x0a, 0x04, 0x6d, 0x61, 0x73, 0x6b, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x0c, 0x0a,
    0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x68,
    0x61, 0x73, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x61,
    0x73, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x73, 0x74, 0x61,
    0x72, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x63, 0x0a, 0x0b, 0x54, 0x65,
    0x78, 0x74, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x63, 0x74,
    0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73,
    0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x0f, 0x0a,
    0x07, 0x74, 0x72, 0x65, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x0f,
    0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x05, 0x20, 0x02, 0x28, 0x09, 0x22,
    0xdf, 0x02, 0x0a, 0x10, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x44, 0x65,
    0x6e, 0x69, 0x65, 0x64, 0x12, 0x12, 0x0a, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07,
    0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a,
    0x06, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x34, 0x0a,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x4d, 0x75,
    0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x44, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x2e, 0x44, 0x65, 0x6e, 0x79, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x09, 0x22, 0xbd, 0x01, 0x0a, 0x08, 0x44, 0x65, 0x6e, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08,
    0x0a, 0x04, 0x54, 0x65, 0x78, 0x74, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x50, 0x65, 0x72, 0x6d,
    0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x53, 0x75, 0x70, 0x65,
    0x72, 0x55, 0x73, 0x65, 0x72, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x43, 0x68, 0x61, 0x6e, 0x6e,
    0x65, 0x6c, 0x4e, 0x61, 0x6d, 0x65, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x65, 0x78, 0x74,
    0x54, 0x6f, 0x6f, 0x4c, 0x6f, 0x6e, 0x67, 0x10, 0x04, 0x12, 0x07, 0x0a, 0x03, 0x48, 0x39, 0x4b,
    0x10, 0x05, 0x12, 0x14, 0x0a, 0x10, 0x54, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x43,
    0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x10, 0x06, 0x12, 0x16, 0x0a, 0x12, 0x4d, 0x69, 0x73, 0x73,
    0x69, 0x6e, 0x67, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x10, 0x07,
    0x12, 0x0c, 0x0a, 0x08, 0x55, 0x73, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x10, 0x08, 0x12, 0x0f,
    0x0a, 0x0b, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x46, 0x75, 0x6c, 0x6c, 0x10, 0x09, 0x12,
    0x10, 0x0a, 0x0c, 0x4e, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x10,
    0x0a, 0x22, 0xd4, 0x03, 0x0a, 0x03, 0x41, 0x43, 0x4c, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x1a, 0x0a,
    0x0c, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x5f, 0x61, 0x63, 0x6c, 0x73, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x2a, 0x0a, 0x06, 0x67, 0x72, 0x6f,
    0x75, 0x70, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x4d, 0x75, 0x6d, 0x62,
    0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x43, 0x68, 0x61, 0x6e,
    0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x26, 0x0a, 0x04, 0x61, 0x63, 0x6c, 0x73, 0x18, 0x04, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x2e, 0x41, 0x43, 0x4c, 0x2e, 0x43, 0x68, 0x61, 0x6e, 0x41, 0x43, 0x4c, 0x12, 0x14, 0x0a,
    0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61,
    0x6c, 0x73, 0x65, 0x1a, 0x9c, 0x01, 0x0a, 0x09, 0x43, 0x68, 0x61, 0x6e, 0x47, 0x72, 0x6f, 0x75,
    0x70, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x17, 0x0a, 0x09, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x15, 0x0a, 0x07, 0x69, 0x6e, 0x68, 0x65,
    0x72, 0x69, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12,
    0x19, 0x0a, 0x0b, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x0b, 0x0a, 0x03, 0x61, 0x64,
    0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x6d, 0x6f, 0x76,
    0x65, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11, 0x69, 0x6e, 0x68, 0x65, 0x72,
    0x69, 0x74, 0x65, 0x64, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x07, 0x20, 0x03,
    0x28, 0x0d, 0x1a, 0x93, 0x01, 0x0a, 0x07, 0x43, 0x68, 0x61, 0x6e, 0x41, 0x43, 0x4c, 0x12, 0x18,
    0x0a, 0x0a, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x5f, 0x68, 0x65, 0x72, 0x65, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x18, 0x0a, 0x0a, 0x61, 0x70, 0x70, 0x6c,
    0x79, 0x5f, 0x73, 0x75, 0x62, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72,
    0x75, 0x65, 0x12, 0x17, 0x0a, 0x09, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x75,
    0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05,
    0x67, 0x72, 0x6f, 0x75, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x67,
    0x72, 0x61, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x65,
    0x6e, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x28, 0x0a, 0x0a, 0x51, 0x75, 0x65, 0x72,
    0x79, 0x55, 0x73, 0x65, 0x72, 0x73, 0x12, 0x0b, 0x0a, 0x03, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03,
    0x28, 0x09, 0x22, 0x45, 0x0a, 0x0a, 0x43, 0x72, 0x79, 0x70, 0x74, 0x53, 0x65, 0x74, 0x75, 0x70,
    0x12, 0x0b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x14, 0x0a,
    0x0c, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0c, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x6e, 0x6f,
    0x6e, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0xd3, 0x01, 0x0a, 0x13, 0x43, 0x6f,
    0x6e, 0x74, 0x65, 0x78, 0x74, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x69, 0x66,
    0x79, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x12, 0x0c, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x0f, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x3d, 0x0a, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0e, 0x32, 0x2a, 0x2e, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,
    0x6f, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4d,
    0x6f, 0x64, 0x69, 0x66, 0x79, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22,
    0x2c, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x10, 0x02, 0x12, 0x08, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x10, 0x04, 0x22, 0x20, 0x0a,
    0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x64,
    0x64, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x10, 0x01, 0x22,
    0x44, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,
    0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18,
    0x03, 0x20, 0x02, 0x28, 0x09, 0x22, 0x85, 0x01, 0x0a, 0x08, 0x55, 0x73, 0x65, 0x72, 0x4c, 0x69,
    0x73, 0x74, 0x12, 0x29, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x1a, 0x2e, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
    0x55, 0x73, 0x65, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x1a, 0x4e, 0x0a,
    0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0f, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x65,
    0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x6c, 0x61, 0x73, 0x74, 0x5f,
    0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xb8, 0x01,
    0x0a, 0x0b, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x0a, 0x0a,
    0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x30, 0x0a, 0x07, 0x74, 0x61, 0x72,
    0x67, 0x65, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x4d, 0x75, 0x6d,
    0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x54, 0x61,
    0x72, 0x67, 0x65, 0x74, 0x2e, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x1a, 0x6b, 0x0a, 0x06, 0x54,
    0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x67, 0x72,
    0x6f, 0x75, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6e,
    0x6b, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12,
    0x17, 0x0a, 0x08, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x22, 0x50, 0x0a, 0x0f, 0x50, 0x65, 0x72, 0x6d,
    0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x12, 0x12, 0x0a, 0x0a, 0x63,
    0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x13, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x22, 0x5c, 0x0a, 0x0c, 0x43, 0x6f,
    0x64, 0x65, 0x63, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x6c,
    0x70, 0x68, 0x61, 0x18, 0x01, 0x20, 0x02, 0x28, 0x05, 0x12, 0x0c, 0x0a, 0x04, 0x62, 0x65, 0x74,
    0x61, 0x18, 0x02, 0x20, 0x02, 0x28, 0x05, 0x12, 0x1a, 0x0a, 0x0c, 0x70, 0x72, 0x65, 0x66, 0x65,
    0x72, 0x5f, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x18, 0x03, 0x20, 0x02, 0x28, 0x08, 0x3a, 0x04, 0x74,
    0x72, 0x75, 0x65, 0x12, 0x13, 0x0a, 0x04, 0x6f, 0x70, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x22, 0xb8, 0x04, 0x0a, 0x09, 0x55, 0x73, 0x65,
    0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x73,
    0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c,
    0x73, 0x65, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
    0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0c, 0x12, 0x31, 0x0a, 0x0b, 0x66, 0x72, 0x6f, 0x6d,
    0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e,
    0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x73, 0x65, 0x72,
    0x53, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x31, 0x0a, 0x0b, 0x66,
    0x72, 0x6f, 0x6d, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x1c, 0x2e, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55,
    0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x13,
    0x0a, 0x0b, 0x75, 0x64, 0x70, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x74, 0x63, 0x70, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65,
    0x74, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x75, 0x64, 0x70, 0x5f,
    0x70, 0x69, 0x6e, 0x67, 0x5f, 0x61, 0x76, 0x67, 0x18, 0x08, 0x20, 0x01, 0x28, 0x02, 0x12, 0x14,
    0x0a, 0x0c, 0x75, 0x64, 0x70, 0x5f, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x72, 0x18, 0x09,
    0x20, 0x01, 0x28, 0x02, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x63, 0x70, 0x5f, 0x70, 0x69, 0x6e, 0x67,
    0x5f, 0x61, 0x76, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x02, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x63,
    0x70, 0x5f, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x72, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x02,
    0x12, 0x25, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0c, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x14, 0x2e, 0x4d, 0x75, 0x6d, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
    0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x65, 0x6c, 0x74, 0x5f,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x05, 0x12, 0x0f,
    0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x11, 0x0a, 0x09, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x18, 0x0f, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x65, 0x63, 0x73,
    0x18, 0x10, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x69, 0x64, 0x6c, 0x65, 0x73, 0x65,
    0x63, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x21, 0x0a, 0x12, 0x73, 0x74, 0x72, 0x6f,
    0x6e, 0x67, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x18, 0x12,
    0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12, 0x13, 0x0a, 0x04, 0x6f,
    0x70, 0x75, 0x73, 0x18, 0x13, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65,
    0x1a, 0x41, 0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x67, 0x6f, 0x6f,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6c, 0x61, 0x74, 0x65, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6c, 0x6f, 0x73, 0x74, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0d, 0x22, 0x5c, 0x0a, 0x0b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6c,
    0x6f, 0x62, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x65,
    0x78, 0x74, 0x75, 0x72, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f, 0x73,
    0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x02,
    0x20, 0x03, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
    0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28,
    0x0d, 0x22, 0x98, 0x01, 0x0a, 0x0c, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66,
    0x69, 0x67, 0x12, 0x15, 0x0a, 0x0d, 0x6d, 0x61, 0x78, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69,
    0x64, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x77, 0x65, 0x6c,
    0x63, 0x6f, 0x6d, 0x65, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x12, 0x0a, 0x0a, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x68, 0x74, 0x6d, 0x6c, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x16, 0x0a, 0x0e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6c,
    0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1c, 0x0a, 0x14, 0x69,
    0x6d, 0x61, 0x67, 0x65, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6c, 0x65, 0x6e,
    0x67, 0x74, 0x68, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x6d, 0x61, 0x78,
    0x5f, 0x75, 0x73, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x4a, 0x0a, 0x0d,
    0x53, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x0f, 0x0a,
    0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12,
    0x0a, 0x0a, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x08, 0x12, 0x14, 0x0a, 0x0c, 0x70, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x6f, 0x5f, 0x74, 0x61,
    0x6c, 0x6b, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x42, 0x02, 0x48, 0x01, 0x4a, 0x93, 0xd5, 0x01,
    0x0a, 0x07, 0x12, 0x05, 0x00, 0x00, 0xa5, 0x04, 0x01, 0x0a, 0x08, 0x0a, 0x01, 0x02, 0x12, 0x03,
    0x00, 0x08, 0x13, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x02, 0x00, 0x1c, 0x0a, 0x0b, 0x0a,
    0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x02, 0x00, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7,
    0x07, 0x00, 0x02, 0x12, 0x03, 0x02, 0x07, 0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00,
    0x02, 0x00, 0x12, 0x03, 0x02, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x02, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x03,
    0x12, 0x03, 0x02, 0x16, 0x1b, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x04, 0x00, 0x0d,
    0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x04, 0x08, 0x0f, 0x0a, 0x4a, 0x0a,
    0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03, 0x06, 0x08, 0x24, 0x1a, 0x3d, 0x20, 0x32, 0x2d, 0x62,
    0x79, 0x74, 0x65, 0x20, 0x4d, 0x61, 0x6a, 0x6f, 0x72, 0x2c, 0x20, 0x31, 0x2d, 0x62, 0x79, 0x74,
    0x65, 0x20, 0x4d, 0x69, 0x6e, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x31, 0x2d, 0x62, 0x79,
    0x74, 0x65, 0x20, 0x50, 0x61, 0x74, 0x63, 0x68, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x03, 0x06, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x03, 0x06, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x06, 0x18, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x06, 0x22,
    0x23, 0x0a, 0x23, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x08, 0x08, 0x24, 0x1a, 0x16,
    0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x20,
    0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x04, 0x12,
    0x03, 0x08, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x05, 0x12, 0x03, 0x08,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x08, 0x18, 0x1f,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x01, 0x03, 0x12, 0x03, 0x08, 0x22, 0x23, 0x0a, 0x1e,
    0x0a, 0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x0a, 0x08, 0x1f, 0x1a, 0x11, 0x20, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x20, 0x4f, 0x53, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x00, 0x02, 0x02, 0x04, 0x12, 0x03, 0x0a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x00, 0x02, 0x02, 0x05, 0x12, 0x03, 0x0a, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x0a, 0x18, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x0a, 0x1d, 0x1e, 0x0a, 0x21, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x03, 0x12, 0x03,
    0x0c, 0x08, 0x27, 0x1a, 0x14, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x4f, 0x53, 0x20,
    0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02,
    0x03, 0x04, 0x12, 0x03, 0x0c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x05,
    0x12, 0x03, 0x0c, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03,
    0x0c, 0x18, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x03, 0x03, 0x12, 0x03, 0x0c, 0x25,
    0x26, 0x0a, 0x3f, 0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x10, 0x00, 0x13, 0x01, 0x1a, 0x33, 0x20,
    0x4e, 0x6f, 0x74, 0x20, 0x75, 0x73, 0x65, 0x64, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x20, 0x65, 0x76,
    0x65, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x75, 0x6e, 0x6e, 0x65, 0x6c, 0x69, 0x6e, 0x67,
    0x20, 0x55, 0x44, 0x50, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x20, 0x54, 0x43, 0x50,
    0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x10, 0x08, 0x11, 0x0a, 0x18,
    0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03, 0x12, 0x08, 0x22, 0x1a, 0x0b, 0x20, 0x4e, 0x6f,
    0x74, 0x20, 0x75, 0x73, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00,
    0x04, 0x12, 0x03, 0x12, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x05, 0x12,
    0x03, 0x12, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x12,
    0x17, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x12, 0x20, 0x21,
    0x0a, 0x56, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x16, 0x00, 0x20, 0x01, 0x1a, 0x4a, 0x20, 0x55,
    0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x75,
    0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x72, 0x65,
    0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12,
    0x03, 0x16, 0x08, 0x14, 0x0a, 0x26, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x03, 0x18, 0x08,
    0x25, 0x1a, 0x19, 0x20, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65,
    0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x03, 0x18, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x00, 0x05, 0x12, 0x03, 0x18, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x18, 0x18, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12,
    0x03, 0x18, 0x23, 0x24, 0x0a, 0x27, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x1a, 0x08,
    0x25, 0x1a, 0x1a, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x01, 0x04, 0x12, 0x03, 0x1a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x01, 0x05, 0x12, 0x03, 0x1a, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x01, 0x01, 0x12, 0x03, 0x1a, 0x18, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03,
    0x12, 0x03, 0x1a, 0x23, 0x24, 0x0a, 0x3e, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x03, 0x1c,
    0x08, 0x23, 0x1a, 0x31, 0x20, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20,
    0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x67, 0x72, 0x6f,
    0x75, 0x70, 0x73, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x03,
    0x1c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x05, 0x12, 0x03, 0x1c, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x1c, 0x18, 0x1e, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x03, 0x12, 0x03, 0x1c, 0x21, 0x22, 0x0a, 0x52, 0x0a,
    0x04, 0x04, 0x02, 0x02, 0x03, 0x12, 0x03, 0x1e, 0x08, 0x29, 0x1a, 0x45, 0x20, 0x41, 0x20, 0x6c,
    0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x43, 0x45, 0x4c, 0x54, 0x20, 0x62, 0x69, 0x74, 0x73,
    0x74, 0x72, 0x65, 0x61, 0x6d, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f,
    0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65,
    0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x04, 0x12, 0x03, 0x1e, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x05, 0x12, 0x03, 0x1e, 0x11, 0x16, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x03, 0x01, 0x12, 0x03, 0x1e, 0x17, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x03, 0x03, 0x12, 0x03, 0x1e, 0x27, 0x28, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02,
    0x04, 0x12, 0x03, 0x1f, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x04, 0x12,
    0x03, 0x1f, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x05, 0x12, 0x03, 0x1f,
    0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x01, 0x12, 0x03, 0x1f, 0x16, 0x1a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x03, 0x12, 0x03, 0x1f, 0x1d, 0x1e, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x08, 0x12, 0x03, 0x1f, 0x1f, 0x30, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x04, 0x07, 0x12, 0x03, 0x1f, 0x2a, 0x2f, 0x0a, 0xe4, 0x01, 0x0a, 0x02, 0x04,
    0x03, 0x12, 0x04, 0x25, 0x00, 0x3c, 0x01, 0x1a, 0xd7, 0x01, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20,
    0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f,
    0x20, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x74, 0x69, 0x6c, 0x6c, 0x20, 0x61, 0x6c, 0x69, 0x76,
    0x65, 0x2e, 0x0a, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20,
    0x72, 0x65, 0x70, 0x6c, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x63,
    0x6b, 0x65, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d,
    0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x69, 0x74, 0x73, 0x20, 0x6f, 0x77, 0x6e, 0x0a, 0x20, 0x67, 0x6f, 0x6f, 0x64, 0x2f, 0x6c, 0x61,
    0x74, 0x65, 0x2f, 0x6c, 0x6f, 0x73, 0x74, 0x2f, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x20, 0x6e,
    0x75, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x2e, 0x20, 0x4e, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x74,
    0x72, 0x69, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x25, 0x08, 0x0c, 0x0a, 0x45, 0x0a,
    0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03, 0x27, 0x08, 0x26, 0x1a, 0x38, 0x20, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x20, 0x53,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x63, 0x6f,
    0x64, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x27,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x05, 0x12, 0x03, 0x27, 0x11, 0x17,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x27, 0x18, 0x21, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x03, 0x27, 0x24, 0x25, 0x0a, 0x33, 0x0a, 0x04,
    0x04, 0x03, 0x02, 0x01, 0x12, 0x03, 0x29, 0x08, 0x21, 0x1a, 0x26, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x67, 0x6f, 0x6f, 0x64, 0x20, 0x70,
    0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x04, 0x12, 0x03, 0x29, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x05, 0x12, 0x03, 0x29, 0x11, 0x17, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x01, 0x01, 0x12, 0x03, 0x29, 0x18, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x01, 0x03, 0x12, 0x03, 0x29, 0x1f, 0x20, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x03, 0x02,
    0x02, 0x12, 0x03, 0x2b, 0x08, 0x21, 0x1a, 0x26, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f,
    0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x20, 0x70, 0x61, 0x63, 0x6b,
    0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x04, 0x12, 0x03, 0x2b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x02, 0x05, 0x12, 0x03, 0x2b, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x02, 0x01, 0x12, 0x03, 0x2b, 0x18, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02,
    0x03, 0x12, 0x03, 0x2b, 0x1f, 0x20, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x03, 0x12, 0x03,
    0x2d, 0x08, 0x21, 0x1a, 0x27, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74,
    0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x6e, 0x65, 0x76, 0x65,
    0x72, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x03, 0x02, 0x03, 0x04, 0x12, 0x03, 0x2d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x03, 0x05, 0x12, 0x03, 0x2d, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03,
    0x01, 0x12, 0x03, 0x2d, 0x18, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x03, 0x03, 0x12,
    0x03, 0x2d, 0x1f, 0x20, 0x0a, 0x2b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x04, 0x12, 0x03, 0x2f, 0x08,
    0x23, 0x1a, 0x1e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f,
    0x66, 0x20, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x20, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x73, 0x2e,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x04, 0x12, 0x03, 0x2f, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x04, 0x05, 0x12, 0x03, 0x2f, 0x11, 0x17, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x04, 0x01, 0x12, 0x03, 0x2f, 0x18, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x04, 0x03, 0x12, 0x03, 0x2f, 0x21, 0x22, 0x0a, 0x38, 0x0a, 0x04, 0x04, 0x03, 0x02,
    0x05, 0x12, 0x03, 0x31, 0x08, 0x28, 0x1a, 0x2b, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x6f, 0x74,
    0x61, 0x6c, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x55, 0x44, 0x50,
    0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x05, 0x04, 0x12, 0x03, 0x31, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x05, 0x05, 0x12, 0x03, 0x31, 0x11, 0x17, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x05, 0x01, 0x12, 0x03, 0x31, 0x18, 0x23, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x05, 0x03, 0x12, 0x03, 0x31, 0x26, 0x27, 0x0a, 0x38, 0x0a, 0x04, 0x04,
    0x03, 0x02, 0x06, 0x12, 0x03, 0x33, 0x08, 0x28, 0x1a, 0x2b, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74,
    0x6f, 0x74, 0x61, 0x6c, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x54,
    0x43, 0x50, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69,
    0x76, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x04, 0x12, 0x03,
    0x33, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x05, 0x12, 0x03, 0x33, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x01, 0x12, 0x03, 0x33, 0x18, 0x23, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x06, 0x03, 0x12, 0x03, 0x33, 0x26, 0x27, 0x0a, 0x20, 0x0a,
    0x04, 0x04, 0x03, 0x02, 0x07, 0x12, 0x03, 0x35, 0x08, 0x28, 0x1a, 0x13, 0x20, 0x55, 0x44, 0x50,
    0x20, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x76, 0x65, 0x72, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x07, 0x04, 0x12, 0x03, 0x35, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x07, 0x05, 0x12, 0x03, 0x35, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x07, 0x01, 0x12, 0x03, 0x35, 0x17, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x07, 0x03, 0x12, 0x03, 0x35, 0x26, 0x27, 0x0a, 0x21, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x08, 0x12,
    0x03, 0x37, 0x08, 0x28, 0x1a, 0x14, 0x20, 0x55, 0x44, 0x50, 0x20, 0x70, 0x69, 0x6e, 0x67, 0x20,
    0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03,
    0x02, 0x08, 0x04, 0x12, 0x03, 0x37, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08,
    0x05, 0x12, 0x03, 0x37, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08, 0x01, 0x12,
    0x03, 0x37, 0x17, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x08, 0x03, 0x12, 0x03, 0x37,
    0x26, 0x27, 0x0a, 0x20, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x09, 0x12, 0x03, 0x39, 0x08, 0x29, 0x1a,
    0x13, 0x20, 0x54, 0x43, 0x50, 0x20, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x76, 0x65, 0x72, 0x61,
    0x67, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x09, 0x04, 0x12, 0x03, 0x39,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x09, 0x05, 0x12, 0x03, 0x39, 0x11, 0x16,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x09, 0x01, 0x12, 0x03, 0x39, 0x17, 0x23, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x09, 0x03, 0x12, 0x03, 0x39, 0x26, 0x28, 0x0a, 0x21, 0x0a, 0x04,
    0x04, 0x03, 0x02, 0x0a, 0x12, 0x03, 0x3b, 0x08, 0x29, 0x1a, 0x14, 0x20, 0x54, 0x43, 0x50, 0x20,
    0x70, 0x69, 0x6e, 0x67, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x0a, 0x04, 0x12, 0x03, 0x3b, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x0a, 0x05, 0x12, 0x03, 0x3b, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x0a, 0x01, 0x12, 0x03, 0x3b, 0x17, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x0a, 0x03, 0x12, 0x03, 0x3b, 0x26, 0x28, 0x0a, 0x45, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0x3f,
    0x00, 0x59, 0x01, 0x1a, 0x39, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74,
    0x20, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0a,
    0x0a, 0x03, 0x04, 0x04, 0x01, 0x12, 0x03, 0x3f, 0x08, 0x0e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x04,
    0x04, 0x00, 0x12, 0x04, 0x40, 0x08, 0x54, 0x09, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x04, 0x00,
    0x01, 0x12, 0x03, 0x40, 0x0d, 0x17, 0x0a, 0x18, 0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x00,
    0x12, 0x03, 0x42, 0x10, 0x19, 0x1a, 0x09, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x20, 0x3f, 0x3f, 0x0a,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x42, 0x10, 0x14,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x03, 0x42, 0x17, 0x18,
    0x0a, 0x4e, 0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x01, 0x12, 0x03, 0x44, 0x10, 0x21, 0x1a,
    0x3f, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x74, 0x74,
    0x65, 0x6d, 0x70, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
    0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x70,
    0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x0a,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x44, 0x10, 0x1c,
    0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x44, 0x1f, 0x20,
    0x0a, 0x42, 0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x02, 0x12, 0x03, 0x46, 0x10, 0x24, 0x1a,
    0x33, 0x20, 0x54, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20,
    0x73, 0x75, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c,
    0x69, 0x64, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12,
    0x03, 0x46, 0x10, 0x1f, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12,
    0x03, 0x46, 0x22, 0x23, 0x0a, 0x62, 0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x03, 0x12, 0x03,
    0x49, 0x10, 0x20, 0x1a, 0x53, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x75,
    0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20,
    0x75, 0x73, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x70, 0x61, 0x73, 0x73,
    0x77, 0x6f, 0x72, 0x64, 0x20, 0x62, 0x75, 0x74, 0x20, 0x69, 0x74, 0x0a, 0x20, 0x77, 0x61, 0x73,
    0x20, 0x77, 0x72, 0x6f, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00,
    0x02, 0x03, 0x01, 0x12, 0x03, 0x49, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00,
    0x02, 0x03, 0x02, 0x12, 0x03, 0x49, 0x1e, 0x1f, 0x0a, 0x64, 0x0a, 0x06, 0x04, 0x04, 0x04, 0x00,
    0x02, 0x04, 0x12, 0x03, 0x4c, 0x10, 0x22, 0x1a, 0x55, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x65, 0x64, 0x20, 0x74,
    0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x70,
    0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x65, 0x64, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
    0x64, 0x0a, 0x20, 0x77, 0x61, 0x73, 0x20, 0x77, 0x72, 0x6f, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x03, 0x4c, 0x10, 0x1d, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x04, 0x02, 0x12, 0x03, 0x4c, 0x20, 0x21, 0x0a, 0x35,
    0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x05, 0x12, 0x03, 0x4e, 0x10, 0x22, 0x1a, 0x26, 0x20,
    0x53, 0x75, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
    0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x69, 0x6e, 0x20,
    0x75, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x05, 0x01,
    0x12, 0x03, 0x4e, 0x10, 0x1d, 0x0a, 0x0e, 0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x05, 0x02,
    0x12, 0x03, 0x4e, 0x20, 0x21, 0x0a, 0x47, 0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x06, 0x12,
    0x03, 0x50, 0x10, 0x1f, 0x1a, 0x38, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x69, 0x73,
    0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x66, 0x75, 0x6c, 0x6c, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70,
    0x74, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x06, 0x01, 0x12, 0x03, 0x50, 0x10, 0x1a, 0x0a, 0x0e,
    0x0a, 0x07, 0x04, 0x04, 0x04, 0x00, 0x02, 0x06, 0x02, 0x12, 0x03, 0x50, 0x1d, 0x1e, 0x0a, 0x4c,
    0x0a, 0x06, 0x04, 0x04, 0x04, 0x00, 0x02, 0x07, 0x12, 0x03, 0x52, 0x10, 0x22, 0x1a, 0x3d, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x64, 0x69, 0x64, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x20, 0x61, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69,
    0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x69,
    0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x04, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x03, 0x52, 0x10, 0x1d, 0x0a, 0x0e, 0x0a, 0x07,
    0x04, 0x04, 0x04, 0x00, 0x02, 0x07, 0x02, 0x12, 0x03, 0x52, 0x20, 0x21, 0x0a, 0x0d, 0x0a, 0x06,
    0x04, 0x04, 0x04, 0x00, 0x02, 0x08, 0x12, 0x03, 0x53, 0x10, 0x26, 0x0a, 0x0e, 0x0a, 0x07, 0x04,
    0x04, 0x04, 0x00, 0x02, 0x08, 0x01, 0x12, 0x03, 0x53, 0x10, 0x21, 0x0a, 0x0e, 0x0a, 0x07, 0x04,
    0x04, 0x04, 0x00, 0x02, 0x08, 0x02, 0x12, 0x03, 0x53, 0x24, 0x25, 0x0a, 0x1e, 0x0a, 0x04, 0x04,
    0x04, 0x02, 0x00, 0x12, 0x03, 0x56, 0x08, 0x25, 0x1a, 0x11, 0x20, 0x52, 0x65, 0x6a, 0x65, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x00, 0x04, 0x12, 0x03, 0x56, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x00, 0x06, 0x12, 0x03, 0x56, 0x11, 0x1b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x56, 0x1c, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x56, 0x23, 0x24, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x01, 0x12, 0x03, 0x58, 0x08, 0x23,
    0x1a, 0x22, 0x20, 0x48, 0x75, 0x6d, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6c,
    0x65, 0x20, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x72, 0x65, 0x61, 0x73,
    0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x04, 0x12, 0x03, 0x58,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x05, 0x12, 0x03, 0x58, 0x11, 0x17,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x01, 0x12, 0x03, 0x58, 0x18, 0x1e, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x03, 0x12, 0x03, 0x58, 0x21, 0x22, 0x0a, 0x87, 0x01, 0x0a,
    0x02, 0x04, 0x05, 0x12, 0x04, 0x5d, 0x00, 0x66, 0x01, 0x1a, 0x7b, 0x20, 0x53, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x53, 0x79, 0x6e, 0x63, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69,
    0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x68, 0x61, 0x73,
    0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x0a, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x69, 0x6e,
    0x69, 0x73, 0x68, 0x65, 0x64, 0x20, 0x73, 0x79, 0x6e, 0x63, 0x68, 0x72, 0x6f, 0x6e, 0x69, 0x7a,
    0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
    0x74, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x03, 0x5d,
    0x08, 0x12, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x03, 0x5f, 0x08, 0x24, 0x1a,
    0x22, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x03, 0x5f, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x03, 0x5f, 0x11, 0x17, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5f, 0x18, 0x1f, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x03, 0x5f, 0x22, 0x23, 0x0a, 0x3a, 0x0a, 0x04, 0x04,
    0x05, 0x02, 0x01, 0x12, 0x03, 0x61, 0x08, 0x2a, 0x1a, 0x2d, 0x20, 0x4d, 0x61, 0x78, 0x69, 0x6d,
    0x75, 0x6d, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x75, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x04,
    0x12, 0x03, 0x61, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x05, 0x12, 0x03,
    0x61, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x01, 0x12, 0x03, 0x61, 0x18,
    0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x03, 0x12, 0x03, 0x61, 0x28, 0x29, 0x0a,
    0x23, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x02, 0x12, 0x03, 0x63, 0x08, 0x29, 0x1a, 0x16, 0x20, 0x53,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65, 0x20, 0x74, 0x65,
    0x78, 0x74, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x03, 0x63,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x05, 0x12, 0x03, 0x63, 0x11, 0x17,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x01, 0x12, 0x03, 0x63, 0x18, 0x24, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x03, 0x12, 0x03, 0x63, 0x27, 0x28, 0x0a, 0x37, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x03, 0x12, 0x03, 0x65, 0x08, 0x28, 0x1a, 0x2a, 0x20, 0x43, 0x75, 0x72, 0x72,
    0x65, 0x6e, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
    0x69, 0x6f, 0x6e, 0x73, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x3a, 0x20, 0x43, 0x6f, 0x6e, 0x66, 0x69,
    0x72, 0x6d, 0x3f, 0x3f, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x04, 0x12, 0x03,
    0x65, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x05, 0x12, 0x03, 0x65, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x01, 0x12, 0x03, 0x65, 0x18, 0x23, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x03, 0x12, 0x03, 0x65, 0x26, 0x27, 0x0a, 0x96, 0x01,
    0x0a, 0x02, 0x04, 0x06, 0x12, 0x04, 0x6a, 0x00, 0x6c, 0x01, 0x1a, 0x89, 0x01, 0x20, 0x53, 0x65,
    0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x61,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64,
    0x2e, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x61, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x72, 0x65,
    0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x69,
    0x66, 0x69, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x03, 0x6a,
    0x08, 0x15, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x03, 0x6b, 0x08, 0x27, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x03, 0x6b, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x03, 0x6b, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x00, 0x01, 0x12, 0x03, 0x6b, 0x18, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x00, 0x03, 0x12, 0x03, 0x6b, 0x25, 0x26, 0x0a, 0xee, 0x01, 0x0a, 0x02, 0x04, 0x07, 0x12, 0x05,
    0x71, 0x00, 0x8c, 0x01, 0x01, 0x1a, 0xe0, 0x01, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x20,
    0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x2e, 0x0a, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x20,
    0x6f, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20,
    0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x2e, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20,
    0x6d, 0x61, 0x79, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x73,
    0x61, 0x69, 0x64, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x70, 0x72, 0x6f, 0x70,
    0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12,
    0x03, 0x71, 0x08, 0x14, 0x0a, 0x3b, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x00, 0x12, 0x03, 0x73, 0x08,
    0x27, 0x1a, 0x2e, 0x20, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x04, 0x12, 0x03, 0x73, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x05, 0x12, 0x03, 0x73, 0x11, 0x17, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12, 0x03, 0x73, 0x18, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x00, 0x03, 0x12, 0x03, 0x73, 0x25, 0x26, 0x0a, 0x30, 0x0a, 0x04, 0x04, 0x07, 0x02,
    0x01, 0x12, 0x03, 0x75, 0x08, 0x23, 0x1a, 0x23, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
    0x5f, 0x69, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6e,
    0x74, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x01, 0x04, 0x12, 0x03, 0x75, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x01, 0x05, 0x12, 0x03, 0x75, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x01,
    0x12, 0x03, 0x75, 0x18, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x01, 0x03, 0x12, 0x03,
    0x75, 0x21, 0x22, 0x0a, 0x2a, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x02, 0x12, 0x03, 0x77, 0x08, 0x21,
    0x1a, 0x1d, 0x20, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x02, 0x04, 0x12, 0x03, 0x77, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x02, 0x05, 0x12, 0x03, 0x77, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x02, 0x01, 0x12, 0x03, 0x77, 0x18, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x02, 0x03, 0x12, 0x03, 0x77, 0x1f, 0x20, 0x0a, 0x72, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x03, 0x12,
    0x03, 0x7a, 0x08, 0x22, 0x1a, 0x65, 0x20, 0x41, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x69,
    0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x6c, 0x69, 0x6e, 0x6b, 0x65, 0x64, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2e,
    0x20, 0x41, 0x62, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x0a, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x03, 0x04, 0x12, 0x03, 0x7a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x03, 0x05, 0x12, 0x03, 0x7a, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x01,
    0x12, 0x03, 0x7a, 0x18, 0x1d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x03, 0x03, 0x12, 0x03,
    0x7a, 0x20, 0x21, 0x0a, 0x61, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x04, 0x12, 0x03, 0x7d, 0x08, 0x28,
    0x1a, 0x54, 0x20, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73,
    0x20, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x0a, 0x20, 0x31, 0x32, 0x38, 0x20,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04, 0x04, 0x12,
    0x03, 0x7d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04, 0x05, 0x12, 0x03, 0x7d,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04, 0x01, 0x12, 0x03, 0x7d, 0x18, 0x23,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x04, 0x03, 0x12, 0x03, 0x7d, 0x26, 0x27, 0x0a, 0x4f,
    0x0a, 0x04, 0x04, 0x07, 0x02, 0x05, 0x12, 0x03, 0x7f, 0x08, 0x26, 0x1a, 0x42, 0x20, 0x41, 0x20,
    0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20,
    0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61,
    0x64, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x2e, 0x0a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x05, 0x04, 0x12, 0x03, 0x7f, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x05, 0x05, 0x12, 0x03, 0x7f, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x05, 0x01, 0x12, 0x03, 0x7f, 0x18, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x05, 0x03, 0x12, 0x03, 0x7f, 0x24, 0x25, 0x0a, 0x54, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x06, 0x12,
    0x04, 0x81, 0x01, 0x08, 0x29, 0x1a, 0x46, 0x20, 0x41, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
    0x69, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73,
    0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x07, 0x02, 0x06, 0x04, 0x12, 0x04, 0x81, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x07, 0x02, 0x06, 0x05, 0x12, 0x04, 0x81, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x06, 0x01, 0x12, 0x04, 0x81, 0x01, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x06, 0x03, 0x12, 0x04, 0x81, 0x01, 0x27, 0x28, 0x0a, 0x31, 0x0a, 0x04, 0x04, 0x07, 0x02,
    0x07, 0x12, 0x04, 0x83, 0x01, 0x08, 0x36, 0x1a, 0x23, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x69, 0x73,
    0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x07, 0x02, 0x07, 0x04, 0x12, 0x04, 0x83, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x07, 0x05, 0x12, 0x04, 0x83, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x07, 0x01, 0x12, 0x04, 0x83, 0x01, 0x16, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x07, 0x03, 0x12, 0x04, 0x83, 0x01, 0x22, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x07,
    0x08, 0x12, 0x04, 0x83, 0x01, 0x24, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x07, 0x07,
    0x12, 0x04, 0x83, 0x01, 0x2f, 0x34, 0x0a, 0x52, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x08, 0x12, 0x04,
    0x85, 0x01, 0x08, 0x32, 0x1a, 0x44, 0x20, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x77, 0x65, 0x61, 0x6b, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x70, 0x6f, 0x73, 0x69,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x08, 0x04, 0x12, 0x04, 0x85, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x08, 0x05, 0x12, 0x04, 0x85, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x08,
    0x01, 0x12, 0x04, 0x85, 0x01, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x08, 0x03,
    0x12, 0x04, 0x85, 0x01, 0x22, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x08, 0x08, 0x12,
    0x04, 0x85, 0x01, 0x24, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x08, 0x07, 0x12, 0x04,
    0x85, 0x01, 0x2f, 0x30, 0x0a, 0x55, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x09, 0x12, 0x04, 0x87, 0x01,
    0x08, 0x2d, 0x1a, 0x47, 0x20, 0x53, 0x48, 0x41, 0x31, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x31, 0x32, 0x38, 0x20, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x07, 0x02, 0x09, 0x04, 0x12, 0x04, 0x87, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x09, 0x05, 0x12, 0x04, 0x87, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x09, 0x01, 0x12, 0x04, 0x87, 0x01, 0x17, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x09,
    0x03, 0x12, 0x04, 0x87, 0x01, 0x2a, 0x2c, 0x0a, 0xc0, 0x01, 0x0a, 0x04, 0x04, 0x07, 0x02, 0x0a,
    0x12, 0x04, 0x8b, 0x01, 0x08, 0x27, 0x1a, 0xb1, 0x01, 0x20, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75,
    0x6d, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x7a, 0x65, 0x72, 0x6f, 0x2c,
    0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x6e, 0x75,
    0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x20, 0x61, 0x6c,
    0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x62, 0x79,
    0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x27, 0x73, 0x20, 0x22,
    0x75, 0x73, 0x65, 0x72, 0x73, 0x70, 0x65, 0x72, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x22,
    0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07,
    0x02, 0x0a, 0x04, 0x12, 0x04, 0x8b, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x0a, 0x05, 0x12, 0x04, 0x8b, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x0a,
    0x01, 0x12, 0x04, 0x8b, 0x01, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x0a, 0x03,
    0x12, 0x04, 0x8b, 0x01, 0x24, 0x26, 0x0a, 0xd2, 0x01, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x06, 0x91,
    0x01, 0x00, 0x9c, 0x01, 0x01, 0x1a, 0xc3, 0x01, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x20, 0x6c, 0x65, 0x61, 0x76, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x72, 0x20, 0x62, 0x65, 0x69,
    0x6e, 0x67, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x65, 0x64, 0x2e, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x62,
    0x65, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x0a, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x61, 0x74,
    0x74, 0x65, 0x6d, 0x70, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x20, 0x61,
    0x20, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69,
    0x74, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e,
    0x74, 0x20, 0x61, 0x6e, 0x79, 0x6d, 0x6f, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x08, 0x01, 0x12, 0x04, 0x91, 0x01, 0x08, 0x12, 0x0a, 0x74, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x00,
    0x12, 0x04, 0x94, 0x01, 0x08, 0x24, 0x1a, 0x66, 0x20, 0x54, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x69, 0x73, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6b,
    0x69, 0x63, 0x6b, 0x65, 0x64, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65,
    0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69,
    0x6f, 0x6e, 0x2c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x0a,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x6e, 0x6f, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x69, 0x73, 0x20,
    0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x01, 0x22, 0x23, 0x0a, 0x80, 0x01, 0x0a, 0x04, 0x04,
    0x08, 0x02, 0x01, 0x12, 0x04, 0x97, 0x01, 0x08, 0x22, 0x1a, 0x72, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x72, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74,
    0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x2e, 0x20,
    0x45, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20,
    0x77, 0x68, 0x6f, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x6b, 0x69, 0x63, 0x6b, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
    0x74, 0x6c, 0x79, 0x20, 0x6c, 0x65, 0x61, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x01, 0x04, 0x12, 0x04, 0x97, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x01, 0x05, 0x12, 0x04, 0x97, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x01, 0x01, 0x12, 0x04, 0x97, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x97, 0x01, 0x20, 0x21, 0x0a, 0x54, 0x0a, 0x04, 0x04, 0x08, 0x02,
    0x02, 0x12, 0x04, 0x99, 0x01, 0x08, 0x23, 0x1a, 0x46, 0x20, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x2c, 0x20, 0x73,
    0x74, 0x6f, 0x72, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x6e,
    0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75,
    0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x04, 0x99, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x05, 0x12, 0x04, 0x99, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x02, 0x01, 0x12, 0x04, 0x99, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x08, 0x02, 0x02, 0x03, 0x12, 0x04, 0x99, 0x01, 0x21, 0x22, 0x0a, 0x38, 0x0a, 0x04, 0x04,
    0x08, 0x02, 0x03, 0x12, 0x04, 0x9b, 0x01, 0x08, 0x1e, 0x1a, 0x2a, 0x20, 0x54, 0x72, 0x75, 0x65,
    0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x20, 0x73, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20,
    0x62, 0x61, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x04, 0x12, 0x04,
    0x9b, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x05, 0x12, 0x04, 0x9b,
    0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9b, 0x01,
    0x16, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9b, 0x01, 0x1c,
    0x1d, 0x0a, 0xbb, 0x01, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0xa1, 0x01, 0x00, 0xca, 0x01, 0x01,
    0x1a, 0xac, 0x01, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x6e, 0x65, 0x77, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x73, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x20, 0x46, 0x69,
    0x72, 0x73, 0x74, 0x20, 0x73, 0x65, 0x65, 0x6e, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x20,
    0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x64, 0x75, 0x72, 0x65, 0x2e,
    0x20, 0x4d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20,
    0x69, 0x74, 0x20, 0x77, 0x69, 0x73, 0x68, 0x65, 0x73, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6c,
    0x74, 0x65, 0x72, 0x20, 0x69, 0x74, 0x73, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x11, 0x0a, 0x61, 0x0a, 0x04,
    0x04, 0x09, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x24, 0x1a, 0x53, 0x20, 0x55, 0x6e, 0x69,
    0x71, 0x75, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
    0x20, 0x49, 0x44, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20,
    0x77, 0x68, 0x6f, 0x73, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x69, 0x73, 0x2c, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20,
    0x6f, 0x6e, 0x0a, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa4, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x01, 0x22, 0x23, 0x0a, 0x42, 0x0a, 0x04, 0x04,
    0x09, 0x02, 0x01, 0x12, 0x04, 0xa6, 0x01, 0x08, 0x22, 0x1a, 0x34, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75,
    0x73, 0x65, 0x72, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74,
    0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa6, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa6, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa6, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa6, 0x01, 0x20, 0x21, 0x0a, 0x29, 0x0a, 0x04, 0x04,
    0x09, 0x02, 0x02, 0x12, 0x04, 0xa8, 0x01, 0x08, 0x21, 0x1a, 0x1b, 0x20, 0x55, 0x73, 0x65, 0x72,
    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x20, 0x65, 0x6e, 0x63,
    0x6f, 0x64, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xa8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xa8, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa8,
    0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa8, 0x01,
    0x1f, 0x20, 0x0a, 0x3d, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x03, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x24,
    0x1a, 0x2f, 0x20, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x49, 0x44, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x04, 0x12, 0x04, 0xaa, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x05, 0x12, 0x04, 0xaa, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04, 0xaa, 0x01, 0x18, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04, 0xaa, 0x01, 0x22, 0x23, 0x0a, 0x2d, 0x0a,
    0x04, 0x04, 0x09, 0x02, 0x04, 0x12, 0x04, 0xac, 0x01, 0x08, 0x27, 0x1a, 0x1f, 0x20, 0x43, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x04, 0x04, 0x12, 0x04, 0xac, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x04, 0x05, 0x12, 0x04, 0xac, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xac, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xac, 0x01, 0x25, 0x26, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x05,
    0x12, 0x04, 0xae, 0x01, 0x08, 0x1f, 0x1a, 0x25, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6d, 0x75, 0x74,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x05, 0x04, 0x12, 0x04, 0xae, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x05, 0x05, 0x12, 0x04, 0xae, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x05, 0x01, 0x12, 0x04, 0xae, 0x01, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x05, 0x03, 0x12, 0x04, 0xae, 0x01, 0x1d, 0x1e, 0x0a, 0x36, 0x0a, 0x04, 0x04, 0x09, 0x02,
    0x06, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x1f, 0x1a, 0x28, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65,
    0x61, 0x66, 0x65, 0x6e, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb0, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x05, 0x12, 0x04, 0xb0, 0x01, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x16, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb0, 0x01, 0x1d, 0x1e, 0x0a, 0x66, 0x0a,
    0x04, 0x04, 0x09, 0x02, 0x07, 0x12, 0x04, 0xb3, 0x01, 0x08, 0x23, 0x1a, 0x58, 0x20, 0x54, 0x72,
    0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x68,
    0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x73, 0x75, 0x70, 0x70, 0x72, 0x65, 0x73, 0x73,
    0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x61, 0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x20,
    0x62, 0x79, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x6f, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x0a, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x75,
    0x74, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x07, 0x04, 0x12, 0x04,
    0xb3, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x07, 0x05, 0x12, 0x04, 0xb3,
    0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x07, 0x01, 0x12, 0x04, 0xb3, 0x01,
    0x16, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x07, 0x03, 0x12, 0x04, 0xb3, 0x01, 0x21,
    0x22, 0x0a, 0x30, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x08, 0x12, 0x04, 0xb5, 0x01, 0x08, 0x24, 0x1a,
    0x22, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6d, 0x75, 0x74, 0x65, 0x64, 0x20, 0x73, 0x65, 0x6c,
    0x66, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x08, 0x04, 0x12, 0x04, 0xb5, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x08, 0x05, 0x12, 0x04, 0xb5, 0x01, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x08, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x16, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x08, 0x03, 0x12, 0x04, 0xb5, 0x01, 0x22, 0x23, 0x0a,
    0x33, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x09, 0x12, 0x04, 0xb7, 0x01, 0x08, 0x25, 0x1a, 0x25, 0x20,
    0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x20, 0x68, 0x61, 0x73, 0x20, 0x64, 0x65, 0x61, 0x66, 0x65, 0x6e, 0x65, 0x64, 0x20, 0x73, 0x65,
    0x6c, 0x66, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x09, 0x04, 0x12, 0x04, 0xb7,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x09, 0x05, 0x12, 0x04, 0xb7, 0x01,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x09, 0x01, 0x12, 0x04, 0xb7, 0x01, 0x16,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x09, 0x03, 0x12, 0x04, 0xb7, 0x01, 0x22, 0x24,
    0x0a, 0x38, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x0a, 0x12, 0x04, 0xb9, 0x01, 0x08, 0x24, 0x1a, 0x2a,
    0x20, 0x55, 0x73, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x69, 0x66, 0x20, 0x69,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x31,
    0x32, 0x38, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x0a, 0x04, 0x12, 0x04, 0xb9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x0a, 0x05, 0x12, 0x04, 0xb9, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0a,
    0x01, 0x12, 0x04, 0xb9, 0x01, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0a, 0x03,
    0x12, 0x04, 0xb9, 0x01, 0x21, 0x23, 0x0a, 0x17, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x0b, 0x12, 0x04,
    0xbb, 0x01, 0x08, 0x2b, 0x1a, 0x09, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x20, 0x3f, 0x3f, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xbb, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xbb, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xbb, 0x01, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xbb, 0x01, 0x28, 0x2a, 0x0a, 0x17, 0x0a, 0x04, 0x04,
    0x09, 0x02, 0x0c, 0x12, 0x04, 0xbd, 0x01, 0x08, 0x2d, 0x1a, 0x09, 0x20, 0x54, 0x4f, 0x44, 0x4f,
    0x20, 0x3f, 0x3f, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xbd,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xbd, 0x01,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xbd, 0x01, 0x18,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xbd, 0x01, 0x2a, 0x2c,
    0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x0d, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x25, 0x1a, 0x2c,
    0x20, 0x55, 0x73, 0x65, 0x72, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x66,
    0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6e,
    0x20, 0x31, 0x32, 0x38, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x0d, 0x04, 0x12, 0x04, 0xbf, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x0d, 0x05, 0x12, 0x04, 0xbf, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x0d, 0x01, 0x12, 0x04, 0xbf, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x0d, 0x03, 0x12, 0x04, 0xbf, 0x01, 0x22, 0x24, 0x0a, 0x31, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x0e,
    0x12, 0x04, 0xc1, 0x01, 0x08, 0x22, 0x1a, 0x23, 0x20, 0x54, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73,
    0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x63, 0x65,
    0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xc1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x0e, 0x05, 0x12, 0x04, 0xc1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x0e, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0e,
    0x03, 0x12, 0x04, 0xc1, 0x01, 0x1f, 0x21, 0x0a, 0x46, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x0f, 0x12,
    0x04, 0xc3, 0x01, 0x08, 0x29, 0x1a, 0x38, 0x20, 0x53, 0x48, 0x41, 0x31, 0x20, 0x68, 0x61, 0x73,
    0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x63, 0x6f,
    0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x31, 0x32, 0x38, 0x20,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xc3, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xc3, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xc3, 0x01, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xc3, 0x01, 0x26, 0x28, 0x0a, 0x46, 0x0a, 0x04, 0x04,
    0x09, 0x02, 0x10, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x29, 0x1a, 0x38, 0x20, 0x53, 0x48, 0x41, 0x31,
    0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x20, 0x70, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20,
    0x31, 0x32, 0x38, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x72,
    0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x10, 0x04, 0x12, 0x04, 0xc5, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x10, 0x05, 0x12, 0x04, 0xc5, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x10, 0x01, 0x12, 0x04, 0xc5, 0x01, 0x17, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x10, 0x03, 0x12, 0x04, 0xc5, 0x01, 0x26, 0x28, 0x0a,
    0x37, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x11, 0x12, 0x04, 0xc7, 0x01, 0x08, 0x2c, 0x1a, 0x29, 0x20,
    0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x20, 0x73,
    0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x11,
    0x04, 0x12, 0x04, 0xc7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x11, 0x05,
    0x12, 0x04, 0xc7, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x11, 0x01, 0x12,
    0x04, 0xc7, 0x01, 0x16, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x11, 0x03, 0x12, 0x04,
    0xc7, 0x01, 0x29, 0x2b, 0x0a, 0x38, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x12, 0x12, 0x04, 0xc9, 0x01,
    0x08, 0x25, 0x1a, 0x2a, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
    0x6c, 0x79, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x12, 0x04, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x12, 0x05, 0x12, 0x04, 0xc9, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x12, 0x01, 0x12, 0x04, 0xc9, 0x01, 0x16, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x12, 0x03, 0x12, 0x04, 0xc9, 0x01, 0x22, 0x24, 0x0a, 0xda, 0x01, 0x0a, 0x02, 0x04,
    0x0a, 0x12, 0x06, 0xcf, 0x01, 0x00, 0xe5, 0x01, 0x01, 0x1a, 0xcb, 0x01, 0x20, 0x52, 0x65, 0x6c,
    0x61, 0x79, 0x73, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x6e, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x73, 0x65, 0x6e, 0x64,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x42, 0x61, 0x6e, 0x4c, 0x69, 0x73, 0x74, 0x20, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20,
    0x6d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20,
    0x6f, 0x66, 0x20, 0x62, 0x61, 0x6e, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x71, 0x75, 0x65, 0x72, 0x79,
    0x20, 0x74, 0x68, 0x65, 0x6d, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x72, 0x0a, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x73, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6c, 0x69,
    0x73, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x61, 0x20,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x71, 0x75, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x66,
    0x6f, 0x72, 0x20, 0x69, 0x74, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04,
    0xcf, 0x01, 0x08, 0x0f, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0a, 0x03, 0x00, 0x12, 0x06, 0xd0, 0x01,
    0x08, 0xdf, 0x01, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x03, 0x00, 0x01, 0x12, 0x04, 0xd0,
    0x01, 0x10, 0x18, 0x0a, 0x24, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd2,
    0x01, 0x10, 0x2b, 0x1a, 0x14, 0x20, 0x42, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x20, 0x49, 0x50, 0x20,
    0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd2, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd2, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0a, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x01, 0x1f, 0x26, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0a, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd2, 0x01, 0x29, 0x2a, 0x0a, 0x3c, 0x0a,
    0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x01, 0x10, 0x29, 0x1a, 0x2c, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x75, 0x62, 0x6e, 0x65, 0x74, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x6e, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0a, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd4, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0a, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd4, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd4, 0x01, 0x20, 0x24, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd4, 0x01, 0x27, 0x28, 0x0a,
    0x52, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xd6, 0x01, 0x10, 0x29, 0x1a,
    0x42, 0x20, 0x55, 0x73, 0x65, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x70,
    0x75, 0x72, 0x70, 0x6f, 0x73, 0x65, 0x73, 0x20, 0x28, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x6e,
    0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xd6, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xd6, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xd6, 0x01, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xd6, 0x01, 0x27, 0x28, 0x0a, 0x19, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00, 0x02,
    0x03, 0x12, 0x04, 0xd8, 0x01, 0x10, 0x29, 0x1a, 0x09, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x20, 0x3f,
    0x3f, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd8,
    0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xd8, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xd8, 0x01, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xd8, 0x01, 0x27, 0x28, 0x0a, 0x3f, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x04,
    0x12, 0x04, 0xda, 0x01, 0x10, 0x2b, 0x1a, 0x2f, 0x20, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x6e, 0x20, 0x28, 0x64, 0x6f, 0x65,
    0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x62, 0x61, 0x6e, 0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xda, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xda, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03,
    0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xda, 0x01, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a,
    0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xda, 0x01, 0x29, 0x2a, 0x0a, 0x21, 0x0a, 0x06, 0x04,
    0x0a, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xdc, 0x01, 0x10, 0x2a, 0x1a, 0x11, 0x20, 0x42, 0x61,
    0x6e, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xdc, 0x01, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xdc, 0x01, 0x19, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xdc, 0x01, 0x20,
    0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xdc, 0x01,
    0x28, 0x29, 0x0a, 0x2a, 0x0a, 0x06, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0xde, 0x01,
    0x10, 0x2d, 0x1a, 0x1a, 0x20, 0x42, 0x61, 0x6e, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xde, 0x01, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xde, 0x01, 0x19, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xde, 0x01, 0x20,
    0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0a, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xde, 0x01,
    0x2b, 0x2c, 0x0a, 0x37, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x01, 0x08, 0x23,
    0x1a, 0x29, 0x20, 0x4c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x62, 0x61, 0x6e, 0x20, 0x65,
    0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79,
    0x20, 0x69, 0x6e, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xe1, 0x01, 0x11, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe1, 0x01, 0x1a, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe1, 0x01, 0x21, 0x22, 0x0a, 0x7a, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01, 0x12,
    0x04, 0xe4, 0x01, 0x08, 0x32, 0x1a, 0x6c, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x73,
    0x74, 0x2c, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x73,
    0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x20, 0x6f, 0x6c,
    0x64, 0x0a, 0x20, 0x62, 0x61, 0x6e, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,
    0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe4, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe4, 0x01, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe4, 0x01, 0x16, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe4, 0x01, 0x1e, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x08, 0x12, 0x04, 0xe4, 0x01, 0x20, 0x31, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x07, 0x12, 0x04, 0xe4, 0x01, 0x2b, 0x30, 0x0a, 0x39, 0x0a,
    0x02, 0x04, 0x0b, 0x12, 0x06, 0xe8, 0x01, 0x00, 0xf5, 0x01, 0x01, 0x1a, 0x2b, 0x20, 0x55, 0x73,
    0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x62,
    0x72, 0x6f, 0x61, 0x64, 0x63, 0x61, 0x73, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12,
    0x04, 0xe8, 0x01, 0x08, 0x13, 0x0a, 0x3e, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x00, 0x12, 0x04, 0xea,
    0x01, 0x08, 0x22, 0x1a, 0x30, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69,
    0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x69, 0x74, 0x73, 0x20, 0x73, 0x65, 0x73, 0x73,
    0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xea, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x05, 0x12, 0x04, 0xea,
    0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xea, 0x01,
    0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xea, 0x01, 0x20,
    0x21, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04, 0xec, 0x01, 0x08, 0x24, 0x1a,
    0x3c, 0x20, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x20, 0x66,
    0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x20,
    0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68,
    0x65, 0x69, 0x72, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xec, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xec, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xec, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xec, 0x01, 0x22, 0x23, 0x0a, 0x5c, 0x0a, 0x04, 0x04, 0x0b, 0x02,
    0x02, 0x12, 0x04, 0xef, 0x01, 0x08, 0x27, 0x1a, 0x4e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x73,
    0x65, 0x6e, 0x74, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20,
    0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x0a, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x5f, 0x69, 0x64, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xef, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xef, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xef, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x02, 0x03, 0x12, 0x04, 0xef,
    0x01, 0x25, 0x26, 0x0a, 0x79, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x03, 0x12, 0x04, 0xf2, 0x01, 0x08,
    0x24, 0x1a, 0x6b, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x6f, 0x6f, 0x74, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69,
    0x6e, 0x67, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x72, 0x65, 0x63, 0x75, 0x72,
    0x73, 0x69, 0x76, 0x65, 0x6c, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x76, 0x65, 0x72, 0x61,
    0x6c, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2c, 0x0a, 0x20, 0x69, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x73, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0b, 0x02, 0x03, 0x05, 0x12, 0x04, 0xf2, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf2, 0x01, 0x22, 0x23, 0x0a, 0x4c, 0x0a, 0x04, 0x04, 0x0b,
    0x02, 0x04, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x24, 0x1a, 0x3e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x55,
    0x54, 0x46, 0x2d, 0x38, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x20, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x48, 0x54, 0x4d,
    0x4c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x05,
    0x12, 0x04, 0xf4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xf4, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x04, 0x03, 0x12, 0x04,
    0xf4, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xf7, 0x01, 0x00, 0x9c,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0c, 0x01, 0x12, 0x04, 0xf7, 0x01, 0x08, 0x18, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x0c, 0x04, 0x00, 0x12, 0x06, 0xf8, 0x01, 0x08, 0x8e, 0x02, 0x09, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x04, 0x00, 0x01, 0x12, 0x04, 0xf8, 0x01, 0x0d, 0x15, 0x0a, 0x46,
    0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfa, 0x01, 0x10, 0x19, 0x1a, 0x36,
    0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x65, 0x6e, 0x69, 0x65,
    0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x73,
    0x6f, 0x6e, 0x2c, 0x20, 0x73, 0x65, 0x65, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xfa, 0x01, 0x10, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02,
    0x00, 0x02, 0x12, 0x04, 0xfa, 0x01, 0x17, 0x18, 0x0a, 0x2a, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00,
    0x02, 0x01, 0x12, 0x04, 0xfc, 0x01, 0x10, 0x1f, 0x1a, 0x1a, 0x20, 0x50, 0x65, 0x72, 0x6d, 0x69,
    0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x77, 0x65, 0x72, 0x65, 0x20, 0x64, 0x65, 0x6e, 0x69,
    0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xfc, 0x01, 0x10, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x01, 0x02,
    0x12, 0x04, 0xfc, 0x01, 0x1d, 0x1e, 0x0a, 0x2a, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x02,
    0x12, 0x04, 0xfe, 0x01, 0x10, 0x1e, 0x1a, 0x1a, 0x20, 0x43, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20,
    0x6d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x20, 0x53, 0x75, 0x70, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfe,
    0x01, 0x10, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04,
    0xfe, 0x01, 0x1c, 0x1d, 0x0a, 0x27, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04,
    0x80, 0x02, 0x10, 0x20, 0x1a, 0x17, 0x20, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x63,
    0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x80, 0x02, 0x10, 0x1b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0x80, 0x02, 0x1e, 0x1f, 0x0a,
    0x28, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0x82, 0x02, 0x10, 0x20, 0x1a,
    0x18, 0x20, 0x54, 0x65, 0x78, 0x74, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x74,
    0x6f, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04,
    0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x82, 0x02, 0x10, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c,
    0x04, 0x00, 0x02, 0x04, 0x02, 0x12, 0x04, 0x82, 0x02, 0x1e, 0x1f, 0x0a, 0x37, 0x0a, 0x06, 0x04,
    0x0c, 0x04, 0x00, 0x02, 0x05, 0x12, 0x04, 0x84, 0x02, 0x10, 0x18, 0x1a, 0x27, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x66, 0x6c, 0x75, 0x78, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x6f, 0x72,
    0x20, 0x77, 0x61, 0x73, 0x20, 0x73, 0x70, 0x65, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x77, 0x72, 0x6f,
    0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x05, 0x01, 0x12,
    0x04, 0x84, 0x02, 0x10, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x05, 0x02,
    0x12, 0x04, 0x84, 0x02, 0x16, 0x17, 0x0a, 0x3f, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x06,
    0x12, 0x04, 0x86, 0x02, 0x10, 0x25, 0x1a, 0x2f, 0x20, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64,
    0x20, 0x69, 0x6e, 0x20, 0x74, 0x65, 0x6d, 0x70, 0x6f, 0x72, 0x61, 0x72, 0x79, 0x20, 0x63, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02,
    0x06, 0x01, 0x12, 0x04, 0x86, 0x02, 0x10, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00,
    0x02, 0x06, 0x02, 0x12, 0x04, 0x86, 0x02, 0x23, 0x24, 0x0a, 0x31, 0x0a, 0x06, 0x04, 0x0c, 0x04,
    0x00, 0x02, 0x07, 0x12, 0x04, 0x88, 0x02, 0x10, 0x27, 0x1a, 0x21, 0x20, 0x4f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x73, 0x20, 0x63,
    0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0c, 0x04, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0x88, 0x02, 0x10, 0x22, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x07, 0x02, 0x12, 0x04, 0x88, 0x02, 0x25, 0x26, 0x0a, 0x23,
    0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x08, 0x12, 0x04, 0x8a, 0x02, 0x10, 0x1d, 0x1a, 0x13,
    0x20, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d,
    0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04,
    0x8a, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x08, 0x02, 0x12,
    0x04, 0x8a, 0x02, 0x1b, 0x1c, 0x0a, 0x22, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x09, 0x12,
    0x04, 0x8c, 0x02, 0x10, 0x20, 0x1a, 0x12, 0x20, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20,
    0x69, 0x73, 0x20, 0x66, 0x75, 0x6c, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04,
    0x00, 0x02, 0x09, 0x01, 0x12, 0x04, 0x8c, 0x02, 0x10, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c,
    0x04, 0x00, 0x02, 0x09, 0x02, 0x12, 0x04, 0x8c, 0x02, 0x1e, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x0c, 0x04, 0x00, 0x02, 0x0a, 0x12, 0x04, 0x8d, 0x02, 0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0c, 0x04, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x8d, 0x02, 0x10, 0x1c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0c, 0x04, 0x00, 0x02, 0x0a, 0x02, 0x12, 0x04, 0x8d, 0x02, 0x1f, 0x21, 0x0a, 0x3e, 0x0a,
    0x04, 0x04, 0x0c, 0x02, 0x00, 0x12, 0x04, 0x90, 0x02, 0x08, 0x27, 0x1a, 0x30, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x64, 0x65, 0x6e, 0x69, 0x65, 0x64, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
    0x69, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x00, 0x04, 0x12, 0x04, 0x90, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x00, 0x05, 0x12, 0x04, 0x90, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x90, 0x02, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x90, 0x02, 0x25, 0x26, 0x0a, 0x64, 0x0a, 0x04, 0x04, 0x0c, 0x02,
    0x01, 0x12, 0x04, 0x93, 0x02, 0x08, 0x27, 0x1a, 0x56, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x5f, 0x69, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70,
    0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x61, 0x73, 0x20, 0x64, 0x65,
    0x6e, 0x69, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x69,
    0x73, 0x0a, 0x20, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x93, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x05, 0x12, 0x04, 0x93, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0x93, 0x02, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0x93, 0x02, 0x25, 0x26, 0x0a, 0x4b, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x02, 0x12, 0x04, 0x95, 0x02, 0x08, 0x24, 0x1a, 0x3d, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x72, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x77, 0x61, 0x73, 0x20, 0x64, 0x65, 0x6e,
    0x69, 0x65, 0x64, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2c,
    0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x73,
    0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x95, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x95, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x95, 0x02, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x95, 0x02, 0x22, 0x23, 0x0a, 0x2e, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x03, 0x12, 0x04, 0x97, 0x02,
    0x08, 0x23, 0x1a, 0x20, 0x20, 0x54, 0x65, 0x78, 0x74, 0x75, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x61,
    0x73, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x6e, 0x69,
    0x61, 0x6c, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x04, 0x12, 0x04, 0x97,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x05, 0x12, 0x04, 0x97, 0x02,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x01, 0x12, 0x04, 0x97, 0x02, 0x18,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x03, 0x12, 0x04, 0x97, 0x02, 0x21, 0x22,
    0x0a, 0x23, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x04, 0x12, 0x04, 0x99, 0x02, 0x08, 0x23, 0x1a, 0x15,
    0x20, 0x54, 0x79, 0x70, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x6e,
    0x69, 0x61, 0x6c, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x04, 0x12, 0x04,
    0x99, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x06, 0x12, 0x04, 0x99,
    0x02, 0x11, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x01, 0x12, 0x04, 0x99, 0x02,
    0x1a, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x04, 0x03, 0x12, 0x04, 0x99, 0x02, 0x21,
    0x22, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x05, 0x12, 0x04, 0x9b, 0x02, 0x08, 0x21, 0x1a,
    0x31, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
    0x69, 0x73, 0x20, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20,
    0x74, 0x79, 0x70, 0x65, 0x20, 0x69, 0x73, 0x20, 0x55, 0x73, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x04, 0x12, 0x04, 0x9b, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x05, 0x12, 0x04, 0x9b, 0x02, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x01, 0x12, 0x04, 0x9b, 0x02, 0x18, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x05, 0x03, 0x12, 0x04, 0x9b, 0x02, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0x9e, 0x02, 0x00, 0xca, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x0d, 0x01, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x0b, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0d, 0x03,
    0x00, 0x12, 0x06, 0x9f, 0x02, 0x08, 0xaf, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x03,
    0x00, 0x01, 0x12, 0x04, 0x9f, 0x02, 0x10, 0x19, 0x0a, 0x3b, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x00,
    0x02, 0x00, 0x12, 0x04, 0xa1, 0x02, 0x10, 0x29, 0x1a, 0x2b, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x67,
    0x72, 0x6f, 0x75, 0x70, 0x2c, 0x20, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x20, 0x65, 0x6e, 0x63, 0x6f,
    0x64, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa1, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xa1, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xa1, 0x02, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa1, 0x02, 0x27, 0x28, 0x0a, 0x53, 0x0a, 0x06, 0x04, 0x0d, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x10, 0x3d, 0x1a, 0x43, 0x20, 0x54, 0x72, 0x75, 0x65,
    0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x68, 0x61,
    0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74,
    0x20, 0x28, 0x52, 0x65, 0x61, 0x64, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x29, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa3, 0x02, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3, 0x02, 0x19, 0x1d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x02, 0x1e,
    0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa3, 0x02,
    0x2a, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x01, 0x08, 0x12, 0x04, 0xa3,
    0x02, 0x2c, 0x3c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x01, 0x07, 0x12, 0x04,
    0xa3, 0x02, 0x37, 0x3b, 0x0a, 0x3a, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04,
    0xa5, 0x02, 0x10, 0x3b, 0x1a, 0x2a, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73,
    0x20, 0x61, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa5, 0x02, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa5, 0x02,
    0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa5,
    0x02, 0x1e, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xa5, 0x02, 0x28, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x08, 0x12,
    0x04, 0xa5, 0x02, 0x2a, 0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x02, 0x07,
    0x12, 0x04, 0xa5, 0x02, 0x35, 0x39, 0x0a, 0x45, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03,
    0x12, 0x04, 0xa7, 0x02, 0x10, 0x3f, 0x1a, 0x35, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62,
    0x65, 0x20, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x73,
    0x75, 0x62, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa7, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa7, 0x02, 0x19, 0x1d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa7, 0x02, 0x1e, 0x29,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa7, 0x02, 0x2c,
    0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03, 0x08, 0x12, 0x04, 0xa7, 0x02,
    0x2e, 0x3e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x03, 0x07, 0x12, 0x04, 0xa7,
    0x02, 0x39, 0x3d, 0x0a, 0x51, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xa9,
    0x02, 0x10, 0x28, 0x1a, 0x41, 0x20, 0x55, 0x73, 0x65, 0x72, 0x73, 0x20, 0x65, 0x78, 0x70, 0x6c,
    0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20,
    0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x2c, 0x20, 0x69,
    0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x5f, 0x69, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xa9, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02,
    0x04, 0x05, 0x12, 0x04, 0xa9, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xa9, 0x02, 0x20, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03,
    0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa9, 0x02, 0x26, 0x27, 0x0a, 0x83, 0x01, 0x0a, 0x06, 0x04,
    0x0d, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xac, 0x02, 0x10, 0x2b, 0x1a, 0x73, 0x20, 0x55, 0x73,
    0x65, 0x72, 0x73, 0x20, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x72,
    0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x63,
    0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x72,
    0x6f, 0x75, 0x70, 0x0a, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x69, 0x6e,
    0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66,
    0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xac, 0x02, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xac, 0x02,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xac,
    0x02, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04,
    0xac, 0x02, 0x29, 0x2a, 0x0a, 0x39, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04,
    0xae, 0x02, 0x10, 0x36, 0x1a, 0x29, 0x20, 0x55, 0x73, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6e, 0x68,
    0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xae, 0x02, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xae, 0x02, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xae, 0x02,
    0x20, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xae,
    0x02, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0d, 0x03, 0x01, 0x12, 0x06, 0xb0, 0x02, 0x08,
    0xbf, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x03, 0x01, 0x01, 0x12, 0x04, 0xb0, 0x02,
    0x10, 0x17, 0x0a, 0x42, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xb2, 0x02,
    0x10, 0x3e, 0x1a, 0x32, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6f,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xb2, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xb2, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xb2, 0x02, 0x1e, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03,
    0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb2, 0x02, 0x2b, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d,
    0x03, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0xb2, 0x02, 0x2d, 0x3d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0d, 0x03, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0xb2, 0x02, 0x38, 0x3c, 0x0a, 0x3f, 0x0a, 0x06,
    0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xb4, 0x02, 0x10, 0x3e, 0x1a, 0x2f, 0x20, 0x54,
    0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x41, 0x43, 0x4c, 0x20,
    0x61, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x75, 0x62, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb4, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb4, 0x02, 0x19, 0x1d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb4, 0x02, 0x1e, 0x28,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb4, 0x02, 0x2b,
    0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x08, 0x12, 0x04, 0xb4, 0x02,
    0x2d, 0x3d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x01, 0x07, 0x12, 0x04, 0xb4,
    0x02, 0x38, 0x3c, 0x0a, 0x45, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xb6,
    0x02, 0x10, 0x3d, 0x1a, 0x35, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x69,
    0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d,
    0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb6, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0d, 0x03, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb6, 0x02, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0d, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x02, 0x1e, 0x27, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb6, 0x02, 0x2a, 0x2b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x02, 0x08, 0x12, 0x04, 0xb6, 0x02, 0x2c, 0x3c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x02, 0x07, 0x12, 0x04, 0xb6, 0x02, 0x37, 0x3b,
    0x0a, 0x3e, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x03, 0x12, 0x04, 0xb8, 0x02, 0x10, 0x2c,
    0x1a, 0x2e, 0x20, 0x49, 0x44, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x41, 0x43, 0x4c, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb8, 0x02, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb8, 0x02,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb8,
    0x02, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xb8, 0x02, 0x2a, 0x2b, 0x0a, 0x3f, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x04, 0x12, 0x04,
    0xba, 0x02, 0x10, 0x2a, 0x1a, 0x2f, 0x20, 0x49, 0x44, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61,
    0x66, 0x66, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x41, 0x43, 0x4c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xba, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xba, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xba, 0x02, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xba, 0x02, 0x28, 0x29, 0x0a, 0x48, 0x0a, 0x06, 0x04, 0x0d, 0x03,
    0x01, 0x02, 0x05, 0x12, 0x04, 0xbc, 0x02, 0x10, 0x2a, 0x1a, 0x38, 0x20, 0x42, 0x69, 0x74, 0x20,
    0x66, 0x6c, 0x61, 0x67, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x67, 0x72,
    0x61, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x41, 0x43,
    0x4c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xbc, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x05, 0x05, 0x12,
    0x04, 0xbc, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xbc, 0x02, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xbc, 0x02, 0x28, 0x29, 0x0a, 0x47, 0x0a, 0x06, 0x04, 0x0d, 0x03, 0x01, 0x02,
    0x06, 0x12, 0x04, 0xbe, 0x02, 0x10, 0x29, 0x1a, 0x37, 0x20, 0x42, 0x69, 0x74, 0x20, 0x66, 0x6c,
    0x61, 0x67, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x64, 0x65, 0x6e, 0x69,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x41, 0x43, 0x4c, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x06, 0x04, 0x12, 0x04, 0xbe, 0x02, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x06, 0x05, 0x12, 0x04, 0xbe, 0x02,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xbe,
    0x02, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x01, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xbe, 0x02, 0x27, 0x28, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00, 0x12, 0x04, 0xc1, 0x02,
    0x08, 0x27, 0x1a, 0x31, 0x20, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x49, 0x44, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x61, 0x66, 0x66, 0x65,
    0x63, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xc1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc1,
    0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc1, 0x02,
    0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc1, 0x02, 0x25,
    0x26, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0xc3, 0x02, 0x08, 0x38, 0x1a,
    0x31, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x69, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x73, 0x20, 0x69,
    0x74, 0x73, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x27, 0x73, 0x20, 0x41, 0x43, 0x4c, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc3, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc3, 0x02, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc3, 0x02, 0x16, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc3, 0x02, 0x25, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x08, 0x12, 0x04, 0xc3, 0x02, 0x27, 0x37, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x01, 0x07, 0x12, 0x04, 0xc3, 0x02, 0x32, 0x36, 0x0a, 0x2a, 0x0a, 0x04,
    0x04, 0x0d, 0x02, 0x02, 0x12, 0x04, 0xc5, 0x02, 0x08, 0x26, 0x1a, 0x1c, 0x20, 0x55, 0x73, 0x65,
    0x72, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xc5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xc5, 0x02, 0x11, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xc5, 0x02, 0x1b, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xc5, 0x02, 0x24, 0x25, 0x0a, 0x23, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x03, 0x12, 0x04, 0xc7, 0x02,
    0x08, 0x22, 0x1a, 0x15, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x03, 0x04, 0x12, 0x04, 0xc7, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03,
    0x06, 0x12, 0x04, 0xc7, 0x02, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xc7, 0x02, 0x19, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xc7, 0x02, 0x20, 0x21, 0x0a, 0x50, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x04, 0x12, 0x04, 0xc9,
    0x02, 0x08, 0x32, 0x1a, 0x42, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x71,
    0x75, 0x65, 0x72, 0x79, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x43, 0x4c, 0x73, 0x20, 0x69, 0x6e,
    0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x74, 0x68, 0x65, 0x6d, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xc9, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xc9, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xc9, 0x02, 0x16, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc9,
    0x02, 0x1e, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x08, 0x12, 0x04, 0xc9, 0x02,
    0x20, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x07, 0x12, 0x04, 0xc9, 0x02, 0x2b,
    0x30, 0x0a, 0xe3, 0x01, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0xcf, 0x02, 0x00, 0xd4, 0x02, 0x01,
    0x1a, 0xd4, 0x01, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x74, 0x6f, 0x20, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x20, 0x69, 0x74, 0x73, 0x20, 0x72,
    0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x69,
    0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x0a,
    0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x66,
    0x69, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x44, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x4e,
    0x61, 0x6d, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x73, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65,
    0x66, 0x72, 0x65, 0x73, 0x68, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x20, 0x66, 0x69, 0x6c, 0x6c, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x69, 0x73,
    0x73, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x61, 0x72, 0x74, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73,
    0x65, 0x6e, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x20, 0x62, 0x61, 0x63, 0x6b, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04,
    0xcf, 0x02, 0x08, 0x12, 0x0a, 0x19, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x04, 0xd1, 0x02,
    0x08, 0x20, 0x1a, 0x0b, 0x20, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd1, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd1, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd1, 0x02, 0x18, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd1, 0x02, 0x1e, 0x1f, 0x0a, 0x34, 0x0a, 0x04, 0x04,
    0x0e, 0x02, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x08, 0x22, 0x1a, 0x26, 0x20, 0x55, 0x73, 0x65, 0x72,
    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
    0x6d, 0x65, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x69, 0x64, 0x73, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd3, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd3, 0x02, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd3, 0x02, 0x18, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd3, 0x02, 0x20, 0x21, 0x0a, 0xf4, 0x01,
    0x0a, 0x02, 0x04, 0x0f, 0x12, 0x06, 0xda, 0x02, 0x00, 0xe1, 0x02, 0x01, 0x1a, 0xe5, 0x01, 0x20,
    0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69,
    0x7a, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x55, 0x44, 0x50, 0x20, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e,
    0x2e, 0x20, 0x45, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x6d, 0x61,
    0x79, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x61, 0x0a, 0x20, 0x72, 0x65, 0x73,
    0x79, 0x6e, 0x63, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f,
    0x75, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x66, 0x69,
    0x6c, 0x6c, 0x65, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63,
    0x20, 0x69, 0x73, 0x0a, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x20, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x0a, 0x20, 0x66, 0x69, 0x6c, 0x6c,
    0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xda, 0x02, 0x08,
    0x12, 0x0a, 0x1f, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x00, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x1f, 0x1a,
    0x11, 0x20, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6b, 0x65, 0x79,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdc, 0x02, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x02, 0x17, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdc, 0x02, 0x1d, 0x1e, 0x0a, 0x1d,
    0x0a, 0x04, 0x04, 0x0f, 0x02, 0x01, 0x12, 0x04, 0xde, 0x02, 0x08, 0x28, 0x1a, 0x0f, 0x20, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xde, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x01, 0x05, 0x12, 0x04, 0xde, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xde, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xde, 0x02, 0x26, 0x27, 0x0a, 0x1d, 0x0a, 0x04, 0x04, 0x0f, 0x02,
    0x02, 0x12, 0x04, 0xe0, 0x02, 0x08, 0x28, 0x1a, 0x0f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x20, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xe0, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xe0, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xe0, 0x02, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xe0, 0x02, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06, 0xe3, 0x02, 0x00, 0xf7,
    0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0xe3, 0x02, 0x08, 0x1b, 0x0a,
    0x0e, 0x0a, 0x04, 0x04, 0x10, 0x04, 0x00, 0x12, 0x06, 0xe4, 0x02, 0x08, 0xeb, 0x02, 0x09, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x04, 0x00, 0x01, 0x12, 0x04, 0xe4, 0x02, 0x0d, 0x14, 0x0a, 0x35,
    0x0a, 0x06, 0x04, 0x10, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe6, 0x02, 0x10, 0x1e, 0x1a, 0x25,
    0x20, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69,
    0x63, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xe6, 0x02, 0x10, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x00, 0x02, 0x00,
    0x02, 0x12, 0x04, 0xe6, 0x02, 0x19, 0x1d, 0x0a, 0x2e, 0x0a, 0x06, 0x04, 0x10, 0x04, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xe8, 0x02, 0x10, 0x1f, 0x1a, 0x1e, 0x20, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x61, 0x20, 0x43, 0x68,
    0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xe8, 0x02, 0x10, 0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x00,
    0x02, 0x01, 0x02, 0x12, 0x04, 0xe8, 0x02, 0x1a, 0x1e, 0x0a, 0x2b, 0x0a, 0x06, 0x04, 0x10, 0x04,
    0x00, 0x02, 0x02, 0x12, 0x04, 0xea, 0x02, 0x10, 0x1c, 0x1a, 0x1b, 0x20, 0x41, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x61, 0x20,
    0x55, 0x73, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xea, 0x02, 0x10, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x00, 0x02,
    0x02, 0x02, 0x12, 0x04, 0xea, 0x02, 0x17, 0x1b, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x10, 0x04, 0x01,
    0x12, 0x06, 0xec, 0x02, 0x08, 0xef, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x04, 0x01,
    0x01, 0x12, 0x04, 0xec, 0x02, 0x0d, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x10, 0x04, 0x01, 0x02,
    0x00, 0x12, 0x04, 0xed, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xed, 0x02, 0x10, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04, 0x01,
    0x02, 0x00, 0x02, 0x12, 0x04, 0xed, 0x02, 0x16, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x10, 0x04,
    0x01, 0x02, 0x01, 0x12, 0x04, 0xee, 0x02, 0x10, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10, 0x04,
    0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xee, 0x02, 0x10, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x10,
    0x04, 0x01, 0x02, 0x01, 0x02, 0x12, 0x04, 0xee, 0x02, 0x19, 0x1a, 0x0a, 0x20, 0x0a, 0x04, 0x04,
    0x10, 0x02, 0x00, 0x12, 0x04, 0xf1, 0x02, 0x08, 0x23, 0x1a, 0x12, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf1, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf1, 0x02, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xf1, 0x02, 0x21, 0x22, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x10, 0x02,
    0x01, 0x12, 0x04, 0xf3, 0x02, 0x08, 0x21, 0x1a, 0x21, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x69,
    0x73, 0x70, 0x6c, 0x61, 0x79, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xf3, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xf3, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xf3, 0x02, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xf3, 0x02, 0x1f, 0x20, 0x0a, 0x50, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x02, 0x12, 0x04,
    0xf5, 0x02, 0x08, 0x24, 0x1a, 0x42, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x20, 0x62,
    0x69, 0x74, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x6e,
    0x67, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x64, 0x69, 0x73,
    0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xf5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xf5, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xf5, 0x02, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xf5, 0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x03, 0x12, 0x04, 0xf6, 0x02,
    0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf6, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x06, 0x12, 0x04, 0xf6, 0x02, 0x11, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf6, 0x02, 0x1b, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf6, 0x02, 0x27, 0x28, 0x0a, 0x4e,
    0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xfa, 0x02, 0x00, 0x81, 0x03, 0x01, 0x1a, 0x40, 0x20, 0x53,
    0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x73, 0x20,
    0x74, 0x6f, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x43, 0x6f,
    0x6e, 0x74, 0x65, 0x78, 0x74, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xfa, 0x02, 0x08, 0x15, 0x0a, 0x46, 0x0a, 0x04, 0x04,
    0x11, 0x02, 0x00, 0x12, 0x04, 0xfc, 0x02, 0x08, 0x24, 0x1a, 0x38, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x55, 0x73, 0x65, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e,
    0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfc, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfc, 0x02, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfc, 0x02, 0x18, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x03, 0x12, 0x04, 0xfc, 0x02, 0x22, 0x23, 0x0a,
    0x4c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12, 0x04, 0xfe, 0x02, 0x08, 0x27, 0x1a, 0x3e, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x43, 0x68, 0x61, 0x6e, 0x6e,
    0x65, 0x6c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x2c, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x01, 0x04, 0x12, 0x04, 0xfe, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x01, 0x05, 0x12, 0x04, 0xfe, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfe, 0x02, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xfe, 0x02, 0x25, 0x26, 0x0a, 0x33, 0x0a, 0x04, 0x04, 0x11, 0x02,
    0x02, 0x12, 0x04, 0x80, 0x03, 0x08, 0x23, 0x1a, 0x25, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64,
    0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x04, 0x12, 0x04, 0x80, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x02, 0x05, 0x12, 0x04, 0x80, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x02, 0x01, 0x12, 0x04, 0x80, 0x03, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x02, 0x03, 0x12, 0x04, 0x80, 0x03, 0x21, 0x22, 0x0a, 0x2b, 0x0a, 0x02, 0x04, 0x12,
    0x12, 0x06, 0x84, 0x03, 0x00, 0x8f, 0x03, 0x01, 0x1a, 0x1d, 0x20, 0x4c, 0x69, 0x73, 0x74, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20,
    0x75, 0x73, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x12, 0x01, 0x12, 0x04,
    0x84, 0x03, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x12, 0x03, 0x00, 0x12, 0x06, 0x85, 0x03,
    0x08, 0x8c, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x03, 0x00, 0x01, 0x12, 0x04, 0x85,
    0x03, 0x10, 0x14, 0x0a, 0x25, 0x0a, 0x06, 0x04, 0x12, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x87,
    0x03, 0x10, 0x2c, 0x1a, 0x15, 0x20, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64,
    0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x49, 0x44, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12,
    0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x87, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x12, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x87, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x12, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x87, 0x03, 0x20, 0x27, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x87, 0x03, 0x2a, 0x2b, 0x0a, 0x27,
    0x0a, 0x06, 0x04, 0x12, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x89, 0x03, 0x10, 0x29, 0x1a, 0x17,
    0x20, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x89, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x89, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x89, 0x03, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x89, 0x03, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x12, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x8a, 0x03, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x12, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8a, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x12, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8a, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8a, 0x03, 0x20, 0x29, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8a, 0x03, 0x2c, 0x2d, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x12, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x8b, 0x03, 0x10, 0x31, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x8b, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x8b, 0x03, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x8b, 0x03,
    0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x12, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0x8b,
    0x03, 0x2f, 0x30, 0x0a, 0x2b, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x00, 0x12, 0x04, 0x8e, 0x03, 0x08,
    0x20, 0x1a, 0x1d, 0x20, 0x41, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x72, 0x65,
    0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8e, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8e, 0x03, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8e, 0x03, 0x16, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8e, 0x03, 0x1e, 0x1f, 0x0a, 0xc1, 0x01, 0x0a,
    0x02, 0x04, 0x13, 0x12, 0x06, 0x95, 0x03, 0x00, 0xa7, 0x03, 0x01, 0x1a, 0xb2, 0x01, 0x20, 0x53,
    0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x73, 0x20,
    0x74, 0x6f, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x63,
    0x6c, 0x65, 0x61, 0x72, 0x20, 0x77, 0x68, 0x69, 0x73, 0x70, 0x65, 0x72, 0x20, 0x74, 0x61, 0x72,
    0x67, 0x65, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x3a, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c,
    0x65, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x49, 0x44, 0x20, 0x69, 0x73, 0x20, 0x31,
    0x20, 0x61, 0x73, 0x20, 0x30, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,
    0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x0a, 0x20, 0x74, 0x61,
    0x6c, 0x6b, 0x69, 0x6e, 0x67, 0x2e, 0x20, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x74,
    0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x49, 0x44, 0x20, 0x69, 0x73, 0x20, 0x33, 0x30, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01, 0x12, 0x04, 0x95, 0x03, 0x08, 0x13, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x13, 0x03, 0x00, 0x12, 0x06, 0x96, 0x03, 0x08, 0xa2, 0x03, 0x09, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x13, 0x03, 0x00, 0x01, 0x12, 0x04, 0x96, 0x03, 0x10, 0x16, 0x0a, 0x35, 0x0a, 0x06,
    0x04, 0x13, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x98, 0x03, 0x10, 0x2c, 0x1a, 0x25, 0x20, 0x55,
    0x73, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x69, 0x6e,
    0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74,
    0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x98, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12,
    0x04, 0x98, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x98, 0x03, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x98, 0x03, 0x2a, 0x2b, 0x0a, 0x38, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0x9a, 0x03, 0x10, 0x2f, 0x1a, 0x28, 0x20, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x63, 0x6c,
    0x75, 0x64, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9a,
    0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x9a, 0x03, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x9a, 0x03, 0x2d, 0x2e, 0x0a, 0x19, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x12,
    0x04, 0x9c, 0x03, 0x10, 0x2a, 0x1a, 0x09, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x20, 0x3f, 0x3f, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9c, 0x03, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9c, 0x03,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9c,
    0x03, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x9c, 0x03, 0x28, 0x29, 0x0a, 0x53, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04,
    0x9e, 0x03, 0x10, 0x3a, 0x1a, 0x43, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x76, 0x6f, 0x69, 0x63, 0x65, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20,
    0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x73, 0x20, 0x66, 0x72, 0x6f,
    0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20,
    0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03,
    0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x9e, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13,
    0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x9e, 0x03, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x13, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9e, 0x03, 0x1e, 0x23, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x13, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9e, 0x03, 0x26, 0x27, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x03, 0x08, 0x12, 0x04, 0x9e, 0x03, 0x28, 0x39, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x03, 0x07, 0x12, 0x04, 0x9e, 0x03, 0x33, 0x38, 0x0a,
    0x5d, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xa1, 0x03, 0x10, 0x3d, 0x1a,
    0x4d, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x6f,
    0x69, 0x63, 0x65, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20,
    0x62, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x68, 0x69, 0x6c, 0x64,
    0x72, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69,
    0x66, 0x69, 0x63, 0x0a, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xa1, 0x03, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xa1, 0x03, 0x19, 0x1d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa1, 0x03, 0x1e,
    0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa1, 0x03,
    0x29, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x08, 0x12, 0x04, 0xa1,
    0x03, 0x2b, 0x3c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x04, 0x07, 0x12, 0x04,
    0xa1, 0x03, 0x36, 0x3b, 0x0a, 0x20, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x03,
    0x08, 0x1f, 0x1a, 0x12, 0x20, 0x56, 0x6f, 0x69, 0x63, 0x65, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65,
    0x74, 0x20, 0x49, 0x44, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xa4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xa4, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4,
    0x03, 0x18, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x03,
    0x1d, 0x1e, 0x0a, 0x3e, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x01, 0x12, 0x04, 0xa6, 0x03, 0x08, 0x24,
    0x1a, 0x30, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x73,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x76, 0x6f, 0x69, 0x63, 0x65,
    0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa6, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa6, 0x03, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa6, 0x03, 0x18, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa6, 0x03, 0x22, 0x23, 0x0a, 0xbb,
    0x01, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06, 0xac, 0x03, 0x00, 0xb4, 0x03, 0x01, 0x1a, 0xac, 0x01,
    0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x77, 0x61, 0x6e, 0x74,
    0x73, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x61, 0x20, 0x63, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x63, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x2e, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x0a, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74,
    0x20, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x71, 0x75, 0x65, 0x72, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x73, 0x79, 0x6e,
    0x63, 0x20, 0x61, 0x6c, 0x6c, 0x0a, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20, 0x70,
    0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x14, 0x01, 0x12, 0x04, 0xac, 0x03, 0x08, 0x17, 0x0a, 0x50, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x00, 0x12, 0x04, 0xae, 0x03, 0x08, 0x27, 0x1a, 0x42, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65,
    0x6c, 0x5f, 0x69, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e,
    0x6e, 0x65, 0x6c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x71, 0x75, 0x65, 0x72, 0x69, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0xae, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xae, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xae, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xae, 0x03, 0x25, 0x26, 0x0a, 0x24, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x01, 0x12,
    0x04, 0xb0, 0x03, 0x08, 0x28, 0x1a, 0x16, 0x20, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x20,
    0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb0, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb0, 0x03, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xb0, 0x03, 0x26, 0x27, 0x0a, 0x64, 0x0a, 0x04, 0x04, 0x14, 0x02,
    0x02, 0x12, 0x04, 0xb3, 0x03, 0x08, 0x32, 0x1a, 0x56, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x20, 0x69, 0x74, 0x73, 0x20, 0x63, 0x75, 0x72,
    0x72, 0x65, 0x6e, 0x74, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20,
    0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x61, 0x6c, 0x6c, 0x0a, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb3, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb3, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x03, 0x16, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb3, 0x03, 0x1e, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x02, 0x08, 0x12, 0x04, 0xb3, 0x03, 0x20, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x02, 0x07, 0x12, 0x04, 0xb3, 0x03, 0x2b, 0x30, 0x0a, 0xa5, 0x01, 0x0a, 0x02, 0x04, 0x15,
    0x12, 0x06, 0xb8, 0x03, 0x00, 0xc0, 0x03, 0x01, 0x1a, 0x96, 0x01, 0x20, 0x53, 0x65, 0x6e, 0x74,
    0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x74,
    0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73, 0x65,
    0x72, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x45, 0x4c, 0x54, 0x20, 0x63, 0x6f,
    0x64, 0x65, 0x63, 0x20, 0x74, 0x68, 0x65, 0x79, 0x0a, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64,
    0x20, 0x75, 0x73, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x63,
    0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x65, 0x6e,
    0x20, 0x6e, 0x65, 0x77, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x20, 0x6a, 0x6f, 0x69, 0x6e, 0x2e,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04, 0xb8, 0x03, 0x08, 0x14, 0x0a, 0x34,
    0x0a, 0x04, 0x04, 0x15, 0x02, 0x00, 0x12, 0x04, 0xba, 0x03, 0x08, 0x21, 0x1a, 0x26, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x43, 0x45, 0x4c, 0x54, 0x20, 0x41, 0x6c, 0x70, 0x68, 0x61, 0x20, 0x63, 0x6f, 0x64,
    0x65, 0x63, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x04, 0x12, 0x04, 0xba,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x05, 0x12, 0x04, 0xba, 0x03,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x01, 0x12, 0x04, 0xba, 0x03, 0x17,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x03, 0x12, 0x04, 0xba, 0x03, 0x1f, 0x20,
    0x0a, 0x33, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x03, 0x08, 0x20, 0x1a, 0x25,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x43, 0x45, 0x4c, 0x54, 0x20, 0x42, 0x65, 0x74, 0x61, 0x20, 0x63, 0x6f,
    0x64, 0x65, 0x63, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xbc, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbc,
    0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbc, 0x03,
    0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbc, 0x03, 0x1e,
    0x1f, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x02, 0x12, 0x04, 0xbe, 0x03, 0x08, 0x38, 0x1a,
    0x31, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72,
    0x20, 0x41, 0x6c, 0x70, 0x68, 0x61, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x42, 0x65, 0x74, 0x61,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbe, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbe, 0x03, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbe, 0x03, 0x16, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbe, 0x03, 0x25, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x08, 0x12, 0x04, 0xbe, 0x03, 0x27, 0x37, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x02, 0x07, 0x12, 0x04, 0xbe, 0x03, 0x32, 0x36, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x15, 0x02, 0x03, 0x12, 0x04, 0xbf, 0x03, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xbf, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x03, 0x05, 0x12, 0x04, 0xbf, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xbf, 0x03, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xbf, 0x03, 0x1d, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x08, 0x12,
    0x04, 0xbf, 0x03, 0x1f, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03, 0x07, 0x12, 0x04,
    0xbf, 0x03, 0x2a, 0x2f, 0x0a, 0x4e, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06, 0xc3, 0x03, 0x00, 0xf7,
    0x03, 0x01, 0x1a, 0x40, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6d,
    0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x73, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xc3, 0x03, 0x08,
    0x11, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x16, 0x03, 0x00, 0x12, 0x06, 0xc4, 0x03, 0x08, 0xcd, 0x03,
    0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x03, 0x00, 0x01, 0x12, 0x04, 0xc4, 0x03, 0x10, 0x15,
    0x0a, 0x36, 0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc6, 0x03, 0x10, 0x29,
    0x1a, 0x26, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66,
    0x20, 0x67, 0x6f, 0x6f, 0x64, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65,
    0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xc6, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc6, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc6, 0x03, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x16, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc6, 0x03, 0x27, 0x28, 0x0a, 0x36, 0x0a, 0x06,
    0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x10, 0x29, 0x1a, 0x26, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x61, 0x74,
    0x65, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76,
    0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xc8, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xc8, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xc8, 0x03, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xc8, 0x03, 0x27, 0x28, 0x0a, 0x37, 0x0a, 0x06, 0x04, 0x16, 0x03, 0x00,
    0x02, 0x02, 0x12, 0x04, 0xca, 0x03, 0x10, 0x29, 0x1a, 0x27, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61,
    0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73,
    0x20, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xca, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xca,
    0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xca, 0x03, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xca, 0x03, 0x27, 0x28, 0x0a, 0x2e, 0x0a, 0x06, 0x04, 0x16, 0x03, 0x00, 0x02, 0x03, 0x12,
    0x04, 0xcc, 0x03, 0x10, 0x2b, 0x1a, 0x1e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x75,
    0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x20, 0x72, 0x65, 0x73, 0x79,
    0x6e, 0x63, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xcc, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02, 0x03,
    0x05, 0x12, 0x04, 0xcc, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xcc, 0x03, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x16, 0x03, 0x00,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xcc, 0x03, 0x29, 0x2a, 0x0a, 0x2b, 0x0a, 0x04, 0x04, 0x16, 0x02,
    0x00, 0x12, 0x04, 0xd0, 0x03, 0x08, 0x24, 0x1a, 0x1d, 0x20, 0x55, 0x73, 0x65, 0x72, 0x20, 0x77,
    0x68, 0x6f, 0x73, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65,
    0x20, 0x61, 0x72, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xd0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xd0, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd0,
    0x03, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd0, 0x03,
    0x22, 0x23, 0x0a, 0x50, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x01, 0x12, 0x04, 0xd2, 0x03, 0x08, 0x37,
    0x1a, 0x42, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20,
    0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x6d, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x73, 0x74, 0x61,
    0x74, 0x73, 0x20, 0x28, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x2c, 0x20, 0x70, 0x69, 0x6e,
    0x67, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd2,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd2, 0x03,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd2, 0x03, 0x16,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd2, 0x03, 0x23, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x08, 0x12, 0x04, 0xd2, 0x03, 0x25, 0x36, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x07, 0x12, 0x04, 0xd2, 0x03, 0x30, 0x35, 0x0a, 0x52,
    0x0a, 0x04, 0x04, 0x16, 0x02, 0x02, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x28, 0x1a, 0x44, 0x20, 0x46,
    0x75, 0x6c, 0x6c, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69,
    0x63, 0x61, 0x74, 0x65, 0x20, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61,
    0x74, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x44, 0x45, 0x52, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd4, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd4, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x03, 0x17, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd4, 0x03, 0x26, 0x27, 0x0a, 0x47,
    0x0a, 0x04, 0x04, 0x16, 0x02, 0x03, 0x12, 0x04, 0xd6, 0x03, 0x08, 0x27, 0x1a, 0x39, 0x20, 0x50,
    0x61, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xd6, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x06, 0x12,
    0x04, 0xd6, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xd6, 0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd6,
    0x03, 0x25, 0x26, 0x0a, 0x41, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x04, 0x12, 0x04, 0xd8, 0x03, 0x08,
    0x27, 0x1a, 0x33, 0x20, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x69,
    0x73, 0x74, 0x69, 0x63, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x04, 0x12,
    0x04, 0xd8, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x06, 0x12, 0x04,
    0xd8, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd8,
    0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd8, 0x03,
    0x25, 0x26, 0x0a, 0x2b, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x05, 0x12, 0x04, 0xdb, 0x03, 0x08, 0x28,
    0x1a, 0x1d, 0x20, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x55, 0x44, 0x50,
    0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x04, 0x12, 0x04, 0xdb, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x05, 0x05, 0x12, 0x04, 0xdb, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x05, 0x01, 0x12, 0x04, 0xdb, 0x03, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x05, 0x03, 0x12, 0x04, 0xdb, 0x03, 0x26, 0x27, 0x0a, 0x2b, 0x0a, 0x04, 0x04,
    0x16, 0x02, 0x06, 0x12, 0x04, 0xdd, 0x03, 0x08, 0x28, 0x1a, 0x1d, 0x20, 0x41, 0x6d, 0x6f, 0x75,
    0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x54, 0x43, 0x50, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06,
    0x04, 0x12, 0x04, 0xdd, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x05,
    0x12, 0x04, 0xdd, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x01, 0x12,
    0x04, 0xdd, 0x03, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xdd, 0x03, 0x26, 0x27, 0x0a, 0x21, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x07, 0x12, 0x04, 0xdf, 0x03,
    0x08, 0x28, 0x1a, 0x13, 0x20, 0x55, 0x44, 0x50, 0x20, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x76,
    0x65, 0x72, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x04,
    0x12, 0x04, 0xdf, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x05, 0x12,
    0x04, 0xdf, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xdf, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x03, 0x12, 0x04, 0xdf,
    0x03, 0x26, 0x27, 0x0a, 0x22, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x08, 0x12, 0x04, 0xe1, 0x03, 0x08,
    0x28, 0x1a, 0x14, 0x20, 0x55, 0x44, 0x50, 0x20, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x76, 0x61, 0x72,
    0x69, 0x61, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xe1, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x05, 0x12,
    0x04, 0xe1, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xe1, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x03, 0x12, 0x04, 0xe1,
    0x03, 0x26, 0x27, 0x0a, 0x21, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x09, 0x12, 0x04, 0xe3, 0x03, 0x08,
    0x29, 0x1a, 0x13, 0x20, 0x54, 0x43, 0x50, 0x20, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x76, 0x65,
    0x72, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x04, 0x12,
    0x04, 0xe3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x05, 0x12, 0x04,
    0xe3, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x01, 0x12, 0x04, 0xe3,
    0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x03, 0x12, 0x04, 0xe3, 0x03,
    0x26, 0x28, 0x0a, 0x22, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x0a, 0x12, 0x04, 0xe5, 0x03, 0x08, 0x29,
    0x1a, 0x14, 0x20, 0x54, 0x43, 0x50, 0x20, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x76, 0x61, 0x72, 0x69,
    0x61, 0x6e, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0a, 0x04, 0x12,
    0x04, 0xe5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0a, 0x05, 0x12, 0x04,
    0xe5, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xe5,
    0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xe5, 0x03,
    0x26, 0x28, 0x0a, 0x1f, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x0b, 0x12, 0x04, 0xe8, 0x03, 0x08, 0x26,
    0x1a, 0x11, 0x20, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xe8, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x06, 0x12, 0x04, 0xe8, 0x03, 0x11,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xe8, 0x03, 0x19, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xe8, 0x03, 0x23, 0x25, 0x0a,
    0x61, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x0c, 0x12, 0x04, 0xeb, 0x03, 0x08, 0x2a, 0x1a, 0x53, 0x20,
    0x41, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x43, 0x45, 0x4c, 0x54, 0x20, 0x62,
    0x69, 0x74, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x20, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f,
    0x72, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xeb, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xeb, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xeb, 0x03, 0x17, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xeb, 0x03, 0x27, 0x29, 0x0a, 0x22,
    0x0a, 0x04, 0x04, 0x16, 0x02, 0x0d, 0x12, 0x04, 0xed, 0x03, 0x08, 0x24, 0x1a, 0x14, 0x20, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0d, 0x04, 0x12, 0x04, 0xed, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0d, 0x05, 0x12, 0x04, 0xed, 0x03, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xed, 0x03, 0x17, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0d, 0x03, 0x12, 0x04, 0xed, 0x03, 0x21, 0x23, 0x0a, 0x2d,
    0x0a, 0x04, 0x04, 0x16, 0x02, 0x0e, 0x12, 0x04, 0xef, 0x03, 0x08, 0x27, 0x1a, 0x1f, 0x20, 0x42,
    0x61, 0x6e, 0x64, 0x77, 0x69, 0x74, 0x68, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xef, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xef, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xef, 0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x0e, 0x03, 0x12, 0x04, 0xef, 0x03, 0x24, 0x26, 0x0a, 0x24, 0x0a, 0x04, 0x04, 0x16, 0x02,
    0x0f, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x28, 0x1a, 0x16, 0x20, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xf1, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xf1, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xf1, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xf1, 0x03, 0x25, 0x27, 0x0a, 0x2d, 0x0a, 0x04, 0x04,
    0x16, 0x02, 0x10, 0x12, 0x04, 0xf3, 0x03, 0x08, 0x26, 0x1a, 0x1f, 0x20, 0x44, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x6c, 0x61, 0x73, 0x74, 0x20,
    0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x10, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x10, 0x05, 0x12, 0x04, 0xf3, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x10,
    0x01, 0x12, 0x04, 0xf3, 0x03, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x10, 0x03,
    0x12, 0x04, 0xf3, 0x03, 0x23, 0x25, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x11, 0x12, 0x04,
    0xf5, 0x03, 0x08, 0x40, 0x1a, 0x2c, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74,
    0x72, 0x6f, 0x6e, 0x67, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x11, 0x04, 0x12, 0x04, 0xf5, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x11, 0x05, 0x12, 0x04, 0xf5, 0x03, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x11, 0x01, 0x12, 0x04, 0xf5, 0x03, 0x16, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x11, 0x03, 0x12, 0x04, 0xf5, 0x03, 0x2b, 0x2d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x11, 0x08, 0x12, 0x04, 0xf5, 0x03, 0x2e, 0x3f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x11, 0x07, 0x12, 0x04, 0xf5, 0x03, 0x39, 0x3e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x16, 0x02, 0x12, 0x12, 0x04, 0xf6, 0x03, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x12, 0x04, 0x12, 0x04, 0xf6, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x12, 0x05, 0x12, 0x04, 0xf6, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x12,
    0x01, 0x12, 0x04, 0xf6, 0x03, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x12, 0x03,
    0x12, 0x04, 0xf6, 0x03, 0x1d, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x12, 0x08, 0x12,
    0x04, 0xf6, 0x03, 0x20, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x12, 0x07, 0x12, 0x04,
    0xf6, 0x03, 0x2b, 0x30, 0x0a, 0xb8, 0x04, 0x0a, 0x02, 0x04, 0x17, 0x12, 0x06, 0x81, 0x04, 0x00,
    0x88, 0x04, 0x01, 0x1a, 0xa9, 0x04, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x20, 0x62, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x20, 0x64, 0x61, 0x74, 0x61,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x2e, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x6c, 0x61, 0x72,
    0x67, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x6f, 0x72, 0x20,
    0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74,
    0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x73, 0x74, 0x61,
    0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x62,
    0x75, 0x74, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x68, 0x61, 0x73, 0x68, 0x20, 0x69, 0x73, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x72, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61,
    0x73, 0x68, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20,
    0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x73, 0x20, 0x69, 0x74,
    0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x6f, 0x65,
    0x73, 0x20, 0x73, 0x6f, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20,
    0x61, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x42, 0x6c, 0x6f, 0x62, 0x0a, 0x20, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x66,
    0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75,
    0x73, 0x65, 0x72, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x72, 0x20,
    0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x73, 0x0a, 0x20, 0x69, 0x74, 0x20,
    0x77, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70,
    0x6c, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x62, 0x79, 0x20,
    0x73, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77, 0x0a, 0x20, 0x55,
    0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x2f, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c,
    0x53, 0x74, 0x61, 0x74, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73,
    0x20, 0x66, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x69, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x79, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x0a, 0x20, 0x6e, 0x6f, 0x72, 0x6d,
    0x61, 0x6c, 0x6c, 0x79, 0x20, 0x62, 0x65, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74,
    0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x68, 0x61, 0x73, 0x68, 0x65, 0x73, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01, 0x12, 0x04, 0x81, 0x04, 0x08, 0x13, 0x0a, 0x3d, 0x0a, 0x04,
    0x04, 0x17, 0x02, 0x00, 0x12, 0x04, 0x83, 0x04, 0x08, 0x2c, 0x1a, 0x2f, 0x20, 0x73, 0x65, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65,
    0x20, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x83, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x83, 0x04, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x83, 0x04, 0x2a, 0x2b, 0x0a, 0x3d, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x01, 0x12,
    0x04, 0x85, 0x04, 0x08, 0x2c, 0x1a, 0x2f, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65,
    0x64, 0x20, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
    0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x04, 0x12,
    0x04, 0x85, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x05, 0x12, 0x04,
    0x85, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x01, 0x12, 0x04, 0x85,
    0x04, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x03, 0x12, 0x04, 0x85, 0x04,
    0x2a, 0x2b, 0x0a, 0x47, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x02, 0x12, 0x04, 0x87, 0x04, 0x08, 0x30,
    0x1a, 0x39, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x69, 0x64, 0x73, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20,
    0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x20, 0x64, 0x65, 0x73,
    0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x02, 0x04, 0x12, 0x04, 0x87, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x02, 0x05, 0x12, 0x04, 0x87, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x87, 0x04, 0x18, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x02,
    0x03, 0x12, 0x04, 0x87, 0x04, 0x2e, 0x2f, 0x0a, 0x60, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06, 0x8c,
    0x04, 0x00, 0x99, 0x04, 0x01, 0x1a, 0x52, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20,
    0x69, 0x74, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20,
    0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01,
    0x12, 0x04, 0x8c, 0x04, 0x08, 0x14, 0x0a, 0x3d, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04,
    0x8e, 0x04, 0x08, 0x2a, 0x1a, 0x2f, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d,
    0x75, 0x6d, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20,
    0x75, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x8e, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8e,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8e, 0x04,
    0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8e, 0x04, 0x28,
    0x29, 0x0a, 0x24, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x01, 0x12, 0x04, 0x90, 0x04, 0x08, 0x29, 0x1a,
    0x16, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x77, 0x65, 0x6c, 0x63, 0x6f, 0x6d, 0x65,
    0x20, 0x74, 0x65, 0x78, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x90, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x90, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x90, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x03, 0x12, 0x04, 0x90,
    0x04, 0x27, 0x28, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x02, 0x12, 0x04, 0x92, 0x04, 0x08,
    0x25, 0x1a, 0x21, 0x20, 0x54, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x48, 0x54,
    0x4d, 0x4c, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x04, 0x12, 0x04, 0x92,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x05, 0x12, 0x04, 0x92, 0x04,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x01, 0x12, 0x04, 0x92, 0x04, 0x16,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x03, 0x12, 0x04, 0x92, 0x04, 0x23, 0x24,
    0x0a, 0x2c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x03, 0x12, 0x04, 0x94, 0x04, 0x08, 0x2b, 0x1a, 0x1e,
    0x20, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x03, 0x04, 0x12, 0x04, 0x94, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x03, 0x05, 0x12, 0x04, 0x94, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x03, 0x01, 0x12, 0x04, 0x94, 0x04, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x03, 0x03, 0x12, 0x04, 0x94, 0x04, 0x29, 0x2a, 0x0a, 0x2d, 0x0a, 0x04, 0x04, 0x18,
    0x02, 0x04, 0x12, 0x04, 0x96, 0x04, 0x08, 0x31, 0x1a, 0x1f, 0x20, 0x4d, 0x61, 0x78, 0x69, 0x6d,
    0x75, 0x6d, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x04, 0x04, 0x12, 0x04, 0x96, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04,
    0x05, 0x12, 0x04, 0x96, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x01,
    0x12, 0x04, 0x96, 0x04, 0x18, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x03, 0x12,
    0x04, 0x96, 0x04, 0x2f, 0x30, 0x0a, 0x42, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x05, 0x12, 0x04, 0x98,
    0x04, 0x08, 0x26, 0x1a, 0x34, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75,
    0x6d, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x75, 0x73, 0x65, 0x72,
    0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x05, 0x04, 0x12, 0x04, 0x98, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05,
    0x05, 0x12, 0x04, 0x98, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x01,
    0x12, 0x04, 0x98, 0x04, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x03, 0x12,
    0x04, 0x98, 0x04, 0x24, 0x25, 0x0a, 0x82, 0x01, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0x9d, 0x04,
    0x00, 0xa5, 0x04, 0x01, 0x1a, 0x74, 0x20, 0x53, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x66,
    0x6f, 0x72, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x20,
    0x6f, 0x66, 0x20, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x0a, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x61, 0x64, 0x6d, 0x69, 0x6e,
    0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x19,
    0x01, 0x12, 0x04, 0x9d, 0x04, 0x08, 0x15, 0x0a, 0x29, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x00, 0x12,
    0x04, 0x9f, 0x04, 0x08, 0x24, 0x1a, 0x1b, 0x20, 0x53, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65,
    0x64, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9f, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9f, 0x04, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9f, 0x04, 0x18, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9f, 0x04, 0x22, 0x23, 0x0a, 0x5f,
    0x0a, 0x04, 0x04, 0x19, 0x02, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x08, 0x25, 0x1a, 0x51, 0x20, 0x54,
    0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x64, 0x6d, 0x69, 0x6e,
    0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74,
    0x73, 0x20, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x61, 0x75, 0x64,
    0x69, 0x6f, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x6e,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa2, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa2, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x16, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa2, 0x04, 0x23, 0x24, 0x0a, 0x5a, 0x0a, 0x04, 0x04,
    0x19, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x04, 0x08, 0x27, 0x1a, 0x4c, 0x20, 0x54, 0x72, 0x75, 0x65,
    0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x69, 0x73, 0x74,
    0x72, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x73, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x73, 0x20, 0x70,
    0x75, 0x73, 0x68, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x61, 0x6c, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x62,
    0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xa4, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xa4, 0x04, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xa4, 0x04, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa4,
    0x04, 0x25, 0x26,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
